<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Effective Java学习笔记</title>
    <url>/2019/01/13/effective-java-xue-xi-bi-ji/</url>
    <content><![CDATA[<h2 id="第一章：引言"><a href="#第一章：引言" class="headerlink" title="第一章：引言"></a>第一章：引言</h2><h2 id="第二章：创建和销毁对象"><a href="#第二章：创建和销毁对象" class="headerlink" title="第二章：创建和销毁对象"></a>第二章：创建和销毁对象</h2><ol>
<li><p>产生对象时，切忌第一反应就是提供公有构造器,考虑使用静态工厂方法。</p>
</li>
<li><p>重叠构造器模式，就是当属性比较多时，提供多个构造器，构造器参数依次增加。但是可读性比较差</p>
</li>
<li><p>构建器模式：四个参数以上时，建议使用构建器模式</p>
</li>
<li><p>比如一些工具类，我们并不想将这些类进行实例化，所以可以将这个类的无参构造器设置为private的，让外界访问不到，但是可以通过反射的方式进行强行访问。</p>
</li>
<li><p>避免创建不必要的对象：如 String str = new String(“hello”);会创建两个对象，直接使用String str = “hello”;就好了。 </p>
</li>
<li><p>java支持自动装箱，拆箱。使用时要慎重，避免不必要的自动装箱拆箱。如int与Integer之间的使用就要注意，避免频繁的进行转换。</p>
</li>
<li><p>消除过期的对象引用：java对于没用的对象会进行垃圾回收，但并不是说就不用考虑内存的事情了。</p>
</li>
<li><p>如果是由类自己来管理内存，那么就应该小心了。一旦元素被释放掉，那么就应该讲元素的引用置为null;用完了之后不在用的对象一律置为null。</p>
</li>
<li><p>避免使用终结方法finalizer来进行垃圾回收，因为java语言规范不仅不会保证终结方法会被及时的执行，而是不保证会被执行。<br>System.gc()和System.runFinalization()虽然增加了终结方法执行的机会，但是也不会保证一定会执行;  </p>
</li>
</ol>
<h2 id="第三章：对于所有对象都通用的方法"><a href="#第三章：对于所有对象都通用的方法" class="headerlink" title="第三章：对于所有对象都通用的方法"></a>第三章：对于所有对象都通用的方法</h2><p>equals(),hashCode(),comparable()方法。</p>
<ol>
<li><p>equals()方法要满足一致性，自反性，传递性</p>
</li>
<li><p>hashCode()：覆盖equals就要覆盖hashCode()方法。<br>equals方法相等hashCode方法的值需要相等。hashCode相等equals方法不一定相等。</p>
</li>
<li><p>所有的子类都应该覆盖toString()方法。</p>
</li>
<li><p>Cloneable接口是没有方法的。所有实现了Cloneable的方法都应该覆盖Object的clone方法。此方法会首先调用super.clone()，然后修正任何需要修正的域。<br>不可变的类是不支持拷贝的。clone这里有点不大懂,一般情况下也不会用clone。缺点太多。</p>
</li>
<li><p>Comparable接口：如果一个类，实现了Comparable接口，说明这个类实例具有内在的排序性质。</p>
</li>
</ol>
<h2 id="第四章：类和接口"><a href="#第四章：类和接口" class="headerlink" title="第四章：类和接口"></a>第四章：类和接口</h2><ol>
<li><p>第一规则：尽可能的使每个类或成员不被外界访问。实例域不能是公有的。公有类永远都不应该暴露可变的域。<br>final修饰的可变对象的引用：虽然引用本省不能被修改，但是它所引用的对象却可以被修改。<br>设计： 公有类不应该含有公有域，除了静态公有域，但是静态公有域也应该确保修饰的引用是不可变对象。</p>
</li>
<li><p>final修饰的类，这个类是不能被拓展（继承）的。为了防止粗心或者恶意的子类假装对象的状态已经改变，从而破坏类的不可变行为。<br>final修饰的变量不会默认初始化。</p>
</li>
<li><p>如何使类变成不可变的类：</p>
</li>
</ol>
<blockquote>
<ol>
<li><p>为了确保不可变性，类绝对不允许被子类化，需要用final修饰类。并用private final修饰成员变量</p>
</li>
<li><p>将类的所有的构造器都变成私有的，并用静态工厂方法来代替共有的构造器。并用private final修饰成员变量</p>
</li>
<li><p>对外不提供setter()，避免修改成员变量。</p>
</li>
<li><p>不应该直接让成员变量直接指向一个对象的引用，而是对这个对象进行深拷贝。</p>
</li>
</ol>
</blockquote>
<ol start="4">
<li><p>许多不可变的类具有一个或多个非final的域，再第一次访问时，可以将结果缓存在域中，这种情况可以很好的工作，<br>  因为对象是不可变的，它的不可变性如果这些计算如果被再次执行，就会产生相同的结果。延迟初始化，String类就用到了。</p>
</li>
<li><p>坚决不要为每个get方法编写一个相应的set方法。除非有很好的理由要让类变成可变的类，否则就应该是不可变的。<br>如果类不能被做成不可变的，仍然应该限制它的可变性。降低对象可一存在的状态数。即使域成为final的。除非有令人信服的理由使域变成非final的。<br>论是clone还是readObject，都不可以调用可覆盖的方法，不管是以直接还是间接的方式。</p>
</li>
<li><p>复合优于继承<br>注意： 如果父类的构造函数中调用的方法被子类重写，那么调用的会是子类的方法。所以父类的构造器内最好不要调用子类重写的父类的方法。</p>
</li>
<li><p>接口要优于抽象类 —————— 骨架类实现，是为了继承的目的而设计的。</p>
</li>
<li><p>接口应该只用于来定义类型，不应该用来导出常量。</p>
</li>
<li><p>用函数对象表示策略。<br>函数指针的主要用途就是实现策略模式。为了在java中实现这种策略模式，要申明一个接口来表示该策略，<br>并且为每个策略声明一个实现了该接口的类。当一个具体策略只被使用一次时，通常使用匿名类来声明和实例化这个具体策略类。<br>当一个具体策略是被设计用来重复使用的时候，它的类通常就要被实现为私有的静态成员类，并通过公有的静态final域导出，其类型为该策略接口。</p>
</li>
<li><p>嵌套类是指被定义在一个类内部的类。嵌套类存在的目的应该只是为了它的外围类提供服务。<br> <strong>嵌套类有四种：</strong></p>
<ul>
<li><p>静态成员类</p>
</li>
<li><p>非静态成员类</p>
</li>
<li><p>匿名类</p>
</li>
<li><p>局部类（局部类是嵌套在方法里面的）</p>
<p>除了静态成员类，替他三种统称为内部类。<br>静态成员类和非静态成员类的区别：<br>在没有外围类的实例的情况下，要想创建非静态成员类的实例是不可能的。</p>
</li>
</ul>
</li>
<li><p>如果声明成员类不要求访问外围实例(成员变量和方法)，就要始终把statis修饰符放在它的声明中。如果省略了static修饰符，则每个实例都将额外的指向一个外围对象的引用，保存这个引用需要消耗时间和空间，并且不会被垃圾回收。</p>
</li>
<li><p>有时候并不用写一个接口的实现，直接通过匿名内部类的方式来实现可能会更加方便。</p>
</li>
</ol>
<h2 id="第五章：泛型"><a href="#第五章：泛型" class="headerlink" title="第五章：泛型"></a>第五章：泛型</h2><blockquote>
<p>list<E>：读作“E的列表”。每种泛型定义一组参数化的类型。如List<String>（“读作 字符串列表”）是一个参数化的类型，表示元素类型为String类型的列表。如果使用原生态类型，就失去了泛型在安全性和表属性方面的所有优势。</String></E></p>
</blockquote>
<ol>
<li><p>请不要使用原生态类型：要使用泛型，使用List这样的原生态类型，会失掉类型安全性，但是使用List &lt; Object &gt;这样的参数化类型就不会。<br>List&lt; String &gt;可以传递个类型List的参数，但不能传递给List<Object>的参数。<br>无限制通配符类型? 如list<?>,
所以：List<Object>是个参数化类型，表示可以包含任何对象类型的一个集合。
List<?>则是一个通配符类型，表示只能包含某种未知对象类型的一个集合。而List是原生类型，不建议使用。</Object></Object></p>
</li>
<li><p>消除非受检警告：要坚持住，要尽可能的消除每一个非受检警告。@SuppressWarnning注解：应该在尽可能小的范围内使用该注解，永远不要在整个类上使用该注解，<br>非受检警告很重要，要尽可能想办法消除，如果实在消除不了，就使用@SuppressWarnning注解，同时把禁止该警告的原因写下来。<br>每当使用SuppressWarnning(“unchecked”)注解时，都要添加一条注释，说明为什么这么做是安全的。</p>
</li>
<li><p>列表优于数组:<br>数组和泛型区别:</p>
<ul>
<li>数组是协变的，意思是：如果Sub是Super的子类型，那么Sub[]也是Super[]的子类型，泛型是不可协变的。意思是：如果Type1是Type的子类型，<br>但List<Type1>不是List<Type2>的子类型。</Type2></Type1></li>
<li>数组是具体化的，因此数组会在运行时才知道并检查他们的类型元素约束；<br>而泛型是通过擦除来实现的，泛型只是在编译时强化他们的类型信息，并在运行时擦除他们的类型信息，<br>擦除就是使泛型可以与没有使用泛型的代码任意进行互用。</li>
</ul>
</li>
<li><p>泛型是通过擦除实现的，List<Integer>运行时实例的运行类型只是List,List<String>[]运行时实例的运行类型只是List[],<br>擦除就是使泛型可以与没有使用泛型的代码随意进行互用。</String></Integer></p>
</li>
<li><p>泛型没看完，还有三条没看。</p>
</li>
</ol>
<h2 id="第六章：枚举和注解"><a href="#第六章：枚举和注解" class="headerlink" title="第六章：枚举和注解"></a>第六章：枚举和注解</h2><ol>
<li>枚举和注解没看，等第三版的出了在补上。</li>
</ol>
<h2 id="第七章：方法"><a href="#第七章：方法" class="headerlink" title="第七章：方法"></a>第七章：方法</h2><ol>
<li><p>检验参数的有效性</p>
<ul>
<li>在方法执行它的任务之前，考虑参数有哪些限制，把这些限制写到文档中。并在方法的开头处检查他们的参数。养成习惯。</li>
<li>对于非公有的方法，应该使用断言来检查他们的参数。</li>
</ul>
</li>
<li><p>必要时进行保护性拷贝：保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象。而不是针对原始的对象。<br>注意：保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象。</p>
</li>
<li><p>对于参数类型，要优先使用接口而不是类。即方法参数用接口。</p>
</li>
<li><p>慎用重载方法： 要调用哪个重载方法是在编译时做出决定的。对于重载方法的选择是静态的，而对于被覆盖的方法的选择是动态的。<br>重写是机制，重载是例外。</p>
</li>
<li><p>慎用可变参数：可变参数可支持零到多个参数。对可变参数进行重载时要在可变参数的方法内加一个单独的参数以防出现方法一样的情况。</p>
</li>
<li><p>返回类型为数组和集合的方法没理由返回null，而不是返回一个零长度的数组或集合。<br>也就是说长度为零时返回零长度的数组或集合，为null时返回null。</p>
</li>
<li><p>为所有导出的API元素编写文档注释。注释应该是写这个API文档做了什么，而不是为什么这么做。还有前提条件和后置条件也应该写出来。<br>为了正确的编写API文档，必须在每个被导出的类，接口，构造器，属性，方法声明之前增加一个文档注释。<br>不写注释是一种残忍。</p>
</li>
</ol>
<h2 id="第八章：通用程序设计"><a href="#第八章：通用程序设计" class="headerlink" title="第八章：通用程序设计"></a>第八章：通用程序设计</h2><ol>
<li><p>将局部变量的作用域最小化：要是局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。几乎所有的局部变量都需要初始化。<br>也可以通过使方法小而集中使局部变量的作用于最小化，也就是说一个方法不宜过于臃肿，将方法拆分。</p>
</li>
<li><p>了解和使用类库：当你编写一个常见的方法时，可以查一下类库。或许类库中一种有了。类库中的性能会比自己写的好一些。</p>
</li>
<li><p>基本类型优先于包装基本类型。</p>
</li>
<li><p>当心字符串连接的性能：使用StringBuilder来代替String。<br>不要使用字符串连接操作符来合并多个字符串，除非性能无关紧要。</p>
</li>
<li><p>通过接口引用对象：如果有合适的接口类型存在，那么对于参数，返回值，变量和域来说，就都应该使用接口类型进行声明。</p>
</li>
<li><p>谨慎的进行优化：要努力编写好的程序而不是快的程序。</p>
</li>
</ol>
<h2 id="第九章：异常"><a href="#第九章：异常" class="headerlink" title="第九章：异常"></a>第九章：异常</h2><ol>
<li><p>只针对异常的情况下才使用异常。</p>
</li>
<li><p>受检异常是exception类的子类但不能是runtimeexception类的子类。如果是runtimeexception或者error的子类那就是非受检的，这种异常在方法内抛出不需要在签名处throws。<br> 受检的异常：受检异常程序员是可以客官处理的。如文件不存在。<br> 运行时异常：是一种bug。如数组下标越界。<br> 错误：不受程序员控制。一般是系统出错。</p>
</li>
<li><p>努力使失败保持原子性，一般而言，失败的方法调用应该使对象保持在被调用之前的状态。</p>
</li>
<li><p>不要忽略异常：不要使用空的catch快。至少，catch快也应该包含一条说明，解释为什么可以忽略这个异常。</p>
</li>
</ol>
<h2 id="第十章：并发"><a href="#第十章：并发" class="headerlink" title="第十章：并发"></a>第十章：并发</h2><ol>
<li>同步访问共享的可变数据：关键字synchronized可以保证在同一时刻，只有一个线程执行同一个方法，或者一个代码块。<ul>
<li>Long 或 double 不是原子操作。</li>
<li>为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。归咎于java的内存模型。</li>
<li>简而言之，当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步。</li>
<li>如果线程之间只需要通信，而不需要互斥，那么可以考虑使用volatile。volatile关键字不执行互斥访问，但它可以保证任何一个线程在读取的该域的时候都可以看到刚刚被写入的值。</li>
<li>增量操作符（++，–）不是原子的，它执行两部操作：一是读取值，二是写入值。   </li>
<li>当多个线程共享可变数据的时候，每个读或者写数据的线程都必须进行同步。如果没有同步，就无法保证一个线程所作的修改可以被另一个线程获知。</li>
</ul>
</li>
</ol>
<ol start="2">
<li>并发没看完，打算直接看java并发编程的书。</li>
</ol>
<h2 id="第十一章：序列化"><a href="#第十一章：序列化" class="headerlink" title="第十一章：序列化"></a>第十一章：序列化</h2><ol>
<li>没看完，用到的时候再看吧，或者等第三版出了再看。</li>
</ol>
<p>​    </p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA使用JRebel进行热部署</title>
    <url>/2021/01/12/idea-shi-yong-jrebel-jin-xing-re-bu-shu/</url>
    <content><![CDATA[<h1 id="IDEA使用JRebel进行热部署教程"><a href="#IDEA使用JRebel进行热部署教程" class="headerlink" title="IDEA使用JRebel进行热部署教程"></a>IDEA使用JRebel进行热部署教程</h1><h2 id="1-安装JRebel插件"><a href="#1-安装JRebel插件" class="headerlink" title="1. 安装JRebel插件"></a>1. <strong>安装JRebel插件</strong></h2><pre><code>在IDEA-&gt;Settings-plugin下载Jrebel的插件，下载好了重启程序使插件生效</code></pre><p><img src="https://img-blog.csdnimg.cn/20210112115750158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzI2ODk2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2-激活"><a href="#2-激活" class="headerlink" title="2. 激活"></a>2. 激活</h2><ol>
<li><p>直接进入到jrebel的配置项中，点击active now链接进入到激活界面，选择Team URL(connect to online licensing service)方式激活</p>
<p><img src="https://img-blog.csdnimg.cn/20191127182857244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpZXJrYW5n,size_16,color_FFFFFF,t_70" alt="img"></p>
</li>
<li><p>第一行输入： <a href="http://jrebel.qekang.com:80/{guid}" target="_blank" rel="noopener">http://jrebel.qekang.com:80/{guid}</a>  ， guid在<strong><a href="https://jrebel.qekang.com/" target="_blank" rel="noopener">https://jrebel.qekang.com/</a></strong> 这个网站获得<br><img src="https://img-blog.csdnimg.cn/202101121158311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzI2ODk2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>   第二行的email输入任意一个符合个数的email地址即可</p>
<h2 id="3-JRebel使用"><a href="#3-JRebel使用" class="headerlink" title="3. JRebel使用"></a>3. <strong>JRebel使用</strong></h2><ol>
<li><p>设置IDEA自动编译项目，将Build project automatiacally这个选下勾选上。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/41635ebc0a734df2fdbb49908763ecd4.png" alt="img"></p>
<p>   按住ctrl + shift + alt +/  这四个键,      点击registry,将compiler.automake.allow.when.app.running这个选项勾选上，如果已经勾选了，跳过此步骤即可。<br><img src="https://img-blog.csdnimg.cn/20210112115857366.png#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210112115919912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzI2ODk2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol start="2">
<li>设置JRebel Work online 和 Redeploy time</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210112115938743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzI2ODk2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol start="3">
<li>勾选要使用JRebel的项目，这里会在每个项目下面生成一个rebel.xml文件。可通过设置git的.gitignore将这个文件忽略掉。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210112115956724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzI2ODk2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>在git项目的根目录下，创建一个.gitignore文件，将一下内容复制进去即可。git会自动读取文件将符合规则的文件隐藏掉。</p>
<pre><code>*.class

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files #
#*.jar
*.war
*.ear

# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
hs_err_pid*

# ---- Maven
target/
dependency-reduced-pom.xml

# ---- IntelliJ IDEA
*.iws
*.iml
*.ipr
.idea/

# ---- Eclipse
.classpath
.project
.settings/
.metadata/

# ---- Mac OS X
.DS_Store?
.DS_Store
Icon?
# Thumbnails
._*
# Files that might appear on external disk
.Spotlight-V100
.Trashes

# ---- Windows
# Windows image file caches
Thumbs.db
# Folder config file
Desktop.ini

.java-version
#--compile
bin/
tmp/
build/

.gradle/
.vscode/
.tmp

# --- JRebel
/**/rebel.xml


</code></pre><ol start="4">
<li><p>启动项目</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4bb53ef0ada2415e55f1b01ca4403e40.png" alt="img"></p>
</li>
<li><p>修改文件之后使文件热加载</p>
<p>每个文件修改之后，鼠标右键点击文件，点击Compile And Reload File使文件生效</p>
<p><img src="https://img-blog.csdnimg.cn/20210112120013832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzI2ODk2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>至此，JRebel热部署的内容分享完毕，希望能够对大家有所帮助。</p>
]]></content>
      <categories>
        <category>热部署</category>
      </categories>
      <tags>
        <tag>热部署</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL45讲</title>
    <url>/2023/03/01/mysql45-jiang/</url>
    <content><![CDATA[<h1 id="MySQL45讲"><a href="#MySQL45讲" class="headerlink" title="MySQL45讲"></a>MySQL45讲</h1><h2 id="09讲普通索引和唯一索引"><a href="#09讲普通索引和唯一索引" class="headerlink" title="09讲普通索引和唯一索引"></a>09讲普通索引和唯一索引</h2><p>假设，执行查询的语句是 select id from T where k=5</p>
<h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><ul>
<li><p>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。</p>
</li>
<li><p>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</p>
<p>那么，这个不同带来的性能差距会有多少呢？答案是，微乎其微。</p>
</li>
</ul>
<p>你知道的，InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。</p>
<p>因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p>
<p>当然，如果k=5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。</p>
<p>但是，我们之前计算过，对于整型字段，一个数据页可以放近千个key，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的CPU来说可以忽略不计。</p>
<h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><p><strong>change buffer：</strong>当更新一个数据的时候，如果这个数据所在的数据页在内存里面，那么就会直接更新掉。如果不在内存里面的时候，</p>
<p>那么会先将更新的操作记录在change buffer里面。等到下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p>
<p>将change buffer的操作记录应用到原数据页，这个过程称为merge，除了访问数据页会触发merge,系统也会有后台线程定期merge。确保数据的完整性。</p>
<p>唯一索引：由于唯一索引每一次更新数据的时候，都需要将数据页查询出来，判断数据是否重复，索引唯一索引不会触发change buffer。</p>
<p>将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p>
<p>change buffer适用于写多读少的业务。</p>
<p>总结：如果业务上可以确保数据不会重复，那么就用普通索引，可以利用change buffer，性能上会比较好。</p>
<p>如果业务上不能确保数据不会重复，必须借助唯一索引来判断，那么没办法，就使用唯一索引。</p>
<p>如果在大数据量插入的情况下，发现效率慢，那么唯一索引也是一个排查的方向。</p>
<h2 id="13讲为什么表数据删掉一半，表文件大小不变"><a href="#13讲为什么表数据删掉一半，表文件大小不变" class="headerlink" title="13讲为什么表数据删掉一半，表文件大小不变"></a>13讲为什么表数据删掉一半，表文件大小不变</h2><p>我给你简单描述一下引入了Online DDL之后，重建表（alter table t engine = InnoDB）的流程：</p>
<ol>
<li><p>建立一个临时文件，扫描表A主键的所有数据页；</p>
</li>
<li><p>用数据页中表A的记录生成B+树，存储到临时文件中；</p>
</li>
<li><p>生成临时文件的过程中，将所有对A的操作记录在一个日志文件（row log）中，对应的是图中state2的状态；</p>
</li>
<li><p>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表A相同的数据文件，对应的就是图中state3的状态；</p>
</li>
<li><p>用临时文件替换表A的数据文件。</p>
</li>
</ol>
<ul>
<li>从MySQL 5.6版本开始，alter table t engine = InnoDB（也就是recreate；</li>
<li>analyze table t 其实不是重建表，只是对表的索引信息做重新统计，没有修改数据，这个过程中加了MDL读锁；</li>
<li>optimize table t 等于recreate+analyze。</li>
</ul>
<h2 id="24讲MySQL是怎么保证主备一致的"><a href="#24讲MySQL是怎么保证主备一致的" class="headerlink" title="24讲MySQL是怎么保证主备一致的"></a>24讲MySQL是怎么保证主备一致的</h2><p>MySQL的主从同步是通过binlog日志来实现的。MySQL对于数据库所有的修改的修改命令都会记录在binlog日志里面。</p>
<p>格式有两种：statement和row</p>
<p>statement：记录的是真实的命令</p>
<p>row：记录的是原有的数据信息，以及真实数据的主键ID。</p>
<p>建议使用row格式，虽然row格式会占用更多的磁盘空间，消耗IO磁盘，执行速度会慢一点。</p>
<p>但是row格式可以支持误操作后恢复数据。</p>
<h2 id="25讲MySQL是怎么保证高可用的"><a href="#25讲MySQL是怎么保证高可用的" class="headerlink" title="25讲MySQL是怎么保证高可用的"></a>25讲MySQL是怎么保证高可用的</h2><h4 id="主备延迟的来源"><a href="#主备延迟的来源" class="headerlink" title="主备延迟的来源"></a>主备延迟的来源</h4><ol>
<li><p>有些部署条件下，备库所在机器的性能要比主库所在的机器性能差。 </p>
</li>
<li><p>第二种常见的可能了，即备库的压力大</p>
</li>
<li><p>大事务，比如一次性的delete大量的数据。</p>
</li>
<li><p>大表DDL</p>
</li>
</ol>
<p>由于主备延迟的存在，所以在主备切换的时候，就相应的有不同的策略。</p>
<h4 id="可靠性优先策略"><a href="#可靠性优先策略" class="headerlink" title="可靠性优先策略"></a>可靠性优先策略</h4><ol>
<li>判断备库B现在的seconds_behind_master，如果小于某个值（比如5秒）继续下一步，否则持续重试这一步；</li>
<li>把主库A改成只读状态，即把readonly设置为true；</li>
<li>判断备库B的seconds_behind_master的值，直到这个值变成0为止；</li>
<li>把备库B改成可读写状态，也就是把readonly 设置为false；</li>
<li>把业务请求切到备库B。</li>
</ol>
<h4 id="可用性优先策略"><a href="#可用性优先策略" class="headerlink" title="可用性优先策略"></a>可用性优先策略</h4><p>如果我强行把步骤4、5调整到最开始执行，也就是说不等主备数据同步，直接把连接切到备库B，并且让备库B可以读写，那么系统几乎就没有不可用时间了。这个切换流程的代价，就是可能出现数据不一致的情况。</p>
<p>总结：在满足数据可靠性的前提下，MySQL高可用系统的可用性，是依赖于主备延迟的。延迟的时间越小，在主库故障的时候，服务恢复需要的时间就越短，可用性就越高。</p>
<h2 id="26讲备库为什么会延迟好几个小时"><a href="#26讲备库为什么会延迟好几个小时" class="headerlink" title="26讲备库为什么会延迟好几个小时"></a>26讲备库为什么会延迟好几个小时</h2><p><strong>备库并行复制能力。</strong></p>
<p>备库通过io_thread读取binlog日志写到relay log 里面，然后通过sql thread 从relay log 里面读取日志执行写到数据磁盘里面去。</p>
<p><strong>备库并行复制能力：</strong>通过coordinator拆成多个线程，coordinator就是原来的sql_thread, 不过现在它不再直接更新数据了，只负责读取中转日志和分发事务，真正更新日志的，变成了worker线程。</p>
<p>所以，coordinator在分发的时候，需要满足以下这两个基本要求：</p>
<ol>
<li>不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。</li>
<li>同一个事务不能被拆开，必须放到同一个worker中。</li>
</ol>
<p>各个版本的多线程复制，都遵循了这两条基本原则。 </p>
<p>MySQL不同版本对于备库的并行复制能力做了不同的优化，目的都是通过多线程复制，降低备库的延迟时间。</p>
<h2 id="28讲读写分离有哪些坑"><a href="#28讲读写分离有哪些坑" class="headerlink" title="28讲读写分离有哪些坑"></a>28讲读写分离有哪些坑</h2><p>由于主从延迟会导致过期读，比如插入或者修改了数据，在从库上查询不到数据，或者数据没有修改。</p>
<p>删除了数据，在从库上依然能够读到数据。</p>
<p><strong>解决方案有：</strong></p>
<ol>
<li><strong>强制走主库。</strong>业界使用最多。</li>
<li><strong>Sleep方案。</strong>比如页面上先给个提示。</li>
<li><strong>判断主备无延迟方案</strong></li>
<li><strong>等主库位点方案</strong></li>
<li><strong>GTID方案</strong></li>
</ol>
<h2 id="33讲我查这么多数据，会不会把数据库内存打爆"><a href="#33讲我查这么多数据，会不会把数据库内存打爆" class="headerlink" title="33讲我查这么多数据，会不会把数据库内存打爆"></a>33讲我查这么多数据，会不会把数据库内存打爆</h2><p>由于MySQL是边查询边发送的逻辑，所以对于数据量很大的查询，不会再server端保存完整的结果集。</p>
<p>如果客户端读数据不及时，会堵住MySQL的查询过程，但是不会把内存打爆。</p>
<p>此外，全表扫描也是非常耗费IO的。</p>
<h2 id="34讲到底可不可以使用join"><a href="#34讲到底可不可以使用join" class="headerlink" title="34讲到底可不可以使用join"></a>34讲到底可不可以使用join</h2><p>可以使用join，但不建议多个表进行join。并且join的使用尽量使用小表座位驱动表，join的大表字段上需要建立索引。</p>
<p>言而总之，还是尽量少用join吧。sql尽量简单、清晰。</p>
<h2 id="39讲自增主键为什么不是连续的"><a href="#39讲自增主键为什么不是连续的" class="headerlink" title="39讲自增主键为什么不是连续的"></a>39讲自增主键为什么不是连续的</h2><ol>
<li><p>唯一键冲突</p>
</li>
<li><p>事务</p>
</li>
<li><p>自增锁的优化：MySQL在select … insert批量插入数据的时候，会批量申请ID,每次申请到id都是上一次的两倍。</p>
<p>这两个原有都会导致，主键是自增但是非连续的。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>RocketMQ生产消息，消费消息的几种案例</title>
    <url>/2021/04/01/rocketmq-sheng-chan-xiao-xi-xiao-fei-xiao-xi-de-ji-chong-an-li/</url>
    <content><![CDATA[<h2 id="1-Producer发送消息的三种方式"><a href="#1-Producer发送消息的三种方式" class="headerlink" title="1. Producer发送消息的三种方式"></a>1. Producer发送消息的三种方式</h2><p>Producer 发送消息，RocketMQ 提供了三种模式。</p>
<ul>
<li>同步发送</li>
<li>异步发送</li>
<li>OneWay 发送</li>
</ul>
<p>示例代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1、同步发送</span>
SendResult sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//2、异步发送</span>
producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SendCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onSuccess</span><span class="token punctuation">(</span>SendResult sendResult<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onException</span><span class="token punctuation">(</span>Throwable e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//3、 Oneway发送</span>
producer<span class="token punctuation">.</span><span class="token function">sendOneway</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><strong>1、同步发送</strong><br> Producer 向 broker 发送消息，阻塞当前线程等待 broker 响应 发送结果。</li>
<li><strong>2、异步发送</strong><br> Producer 首先构建一个向 broker 发送消息的任务，把该任务提交给线程池，等执行完该任务时，回调用户自定义的回调函数，执行处理结果。</li>
<li><strong>3、Oneway 发送</strong><br> Oneway 方式只负责发送请求，不等待应答，Producer 只负责把请求发出去，而不处理响应结果。</li>
</ul>
<h2 id="2-Consumer消费消息的两种方式"><a href="#2-Consumer消费消息的两种方式" class="headerlink" title="2. Consumer消费消息的两种方式"></a>2. Consumer消费消息的两种方式</h2><p>RocketMQ里面有消费者组的概念。</p>
<p>先说下以下两个问题，方面后续的理解。</p>
<p>问题1：一个消费者组里面为什么会有多个消费者？</p>
<p>​    答：当一个服务有几个节点时，便会有多个消费者。而这些消费者里面应该只有一个消费者能够消费消息。</p>
<p>问题2：为什么会有多个消费者组？</p>
<p>​    答：微服务情况下。一个消息可能会被多个业务服务消费。比如商品服务。优惠券服务。这每个服务都是一个消费者组。</p>
<h3 id="2-1-集群模式"><a href="#2-1-集群模式" class="headerlink" title="2.1 集群模式"></a>2.1 集群模式</h3><pre class=" language-java"><code class="language-java">consumer<span class="token punctuation">.</span><span class="token function">setMessageModel</span><span class="token punctuation">(</span>MessageModel<span class="token punctuation">.</span>CLUSTERING<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>在此模式下，当多个消费者在同一个消费者组时，这些消费者里面只会有一个消费者能够消费消息。</p>
<p>也就是说存在多个消费者组时，每个消费者组里面只会有一个消费者能够消费消息。</p>
<p><strong>故此：消费者组的名字一般是服务的名字。TOPIC的名字一般是哪个服务发出来的，就是哪个服务的名字。</strong></p>
<p><strong>一般使用集群模式即可。</strong></p>
<h3 id="2-2-广播模式"><a href="#2-2-广播模式" class="headerlink" title="2.2 广播模式"></a>2.2 广播模式</h3><pre class=" language-java"><code class="language-java">consumer<span class="token punctuation">.</span><span class="token function">setMessageModel</span><span class="token punctuation">(</span>MessageModel<span class="token punctuation">.</span>BROADCASTING<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>在此模式下。如果多个消费者处于同一个消费者组里面，这个消费者组里面的每个消费者都会消费消息。</p>
<h2 id="3-顺序消息"><a href="#3-顺序消息" class="headerlink" title="3. 顺序消息"></a>3. 顺序消息</h2><p>消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消息有序，可以分为分区有序或者全局有序。</p>
<p>顺序消费的原理解析，在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则就保证了顺序。当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。</p>
<h2 id="4-延时消息"><a href="#4-延时消息" class="headerlink" title="4. 延时消息"></a>4. 延时消息</h2><p>发送者代码示例：</p>
<pre class=" language-java"><code class="language-java">Message message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"topic1"</span><span class="token punctuation">,</span> <span class="token string">"tagA"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"Hello scheduled message "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
message<span class="token punctuation">.</span><span class="token function">setDelayTimeLevel</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
SendResult send <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>延时等级：</p>
<pre class=" language-java"><code class="language-java"> <span class="token keyword">private</span> String messageDelayLevel <span class="token operator">=</span> <span class="token string">"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h"</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>level == 0，消息为非延迟消息</li>
<li>1&lt;=level&lt;=maxLevel，消息延迟特定时间，例如level==1，延迟1s</li>
<li>level &gt; maxLevel，则level== maxLevel，例如level==20，延迟2h</li>
</ul>
<h2 id="5-批量消息"><a href="#5-批量消息" class="headerlink" title="5. 批量消息"></a>5. 批量消息</h2><p>批量发送消息能显著提高传递小消息的性能。限制是这些批量消息应该有相同的topic，相同的waitStoreMsgOK，而且不能是延时消息。此外，这一批消息的总大小不应超过4MB。</p>
<p>如果您每次只发送不超过4MB的消息，则很容易使用批处理，样例如下：</p>
<pre class=" language-java"><code class="language-java">String topic <span class="token operator">=</span> <span class="token string">"BatchTest"</span><span class="token punctuation">;</span>
List<span class="token operator">&lt;</span>Message<span class="token operator">></span> messages <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
messages<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token string">"TagA"</span><span class="token punctuation">,</span> <span class="token string">"OrderID001"</span><span class="token punctuation">,</span> <span class="token string">"Hello world 0"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
messages<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token string">"TagA"</span><span class="token punctuation">,</span> <span class="token string">"OrderID002"</span><span class="token punctuation">,</span> <span class="token string">"Hello world 1"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
messages<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token string">"TagA"</span><span class="token punctuation">,</span> <span class="token string">"OrderID003"</span><span class="token punctuation">,</span> <span class="token string">"Hello world 2"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
   producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>messages<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true">//处理error</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="6-事务消息"><a href="#6-事务消息" class="headerlink" title="6. 事务消息"></a>6. 事务消息</h2><h3 id="6-1-事务消息执行流程"><a href="#6-1-事务消息执行流程" class="headerlink" title="6.1 事务消息执行流程"></a>6.1 事务消息执行流程</h3><p>流程图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210401171744307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzI2ODk2,size_16,color_FFFFFF,t_70" alt></p>
<p>上图说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p>
<h4 id="1）事务消息发送及提交"><a href="#1）事务消息发送及提交" class="headerlink" title="1）事务消息发送及提交"></a>1）事务消息发送及提交</h4><p>(1) 发送消息（half消息）。</p>
<p>(2) 服务端响应消息写入结果。</p>
<p>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p>
<p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p>
<h4 id="2）事务补偿"><a href="#2）事务补偿" class="headerlink" title="2）事务补偿"></a>2）事务补偿</h4><p>(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p>
<p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p>
<p>(3) 根据本地事务状态，重新Commit或者Rollback</p>
<p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p>
<h4 id="3）事务消息状态"><a href="#3）事务消息状态" class="headerlink" title="3）事务消息状态"></a>3）事务消息状态</h4><p>事务消息共有三种状态，提交状态、回滚状态、中间状态：</p>
<ul>
<li>TransactionStatus.CommitTransaction: 提交事务，它允许消费者消费此消息。</li>
<li>TransactionStatus.RollbackTransaction: 回滚事务，它代表该消息将被删除，不允许被消费。</li>
<li>TransactionStatus.Unknown: 中间状态，它代表需要检查消息队列来确定状态。</li>
</ul>
<h3 id="6-2-发送事务消息"><a href="#6-2-发送事务消息" class="headerlink" title="6.2 发送事务消息"></a>6.2 发送事务消息</h3><h4 id="1）-创建事务消息生产者"><a href="#1）-创建事务消息生产者" class="headerlink" title="1） 创建事务消息生产者"></a>1） 创建事务消息生产者</h4><p>使用 <code>TransactionMQProducer</code>类创建生产者，并指定唯一的 <code>ProducerGroup</code>，就可以设置自定义线程池来处理这些检查请求。执行本地事务后、需要根据执行结果对消息队列进行回复。回传的事务状态在请参考前一节。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionProducer</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
            <span class="token keyword">throws</span> MQClientException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>

        <span class="token comment" spellcheck="true">// 创建事务监听器</span>
        TransactionListener transactionListener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransactionListenerImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 创建消息生产者</span>
        TransactionMQProducer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransactionMQProducer</span><span class="token punctuation">(</span><span class="token string">"group6"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"139.224.103.236:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 生产者这是监听器</span>
        producer<span class="token punctuation">.</span><span class="token function">setTransactionListener</span><span class="token punctuation">(</span>transactionListener<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 启动消息生产者</span>
        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                Message msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"TransactionTopicTest"</span><span class="token punctuation">,</span>
                        <span class="token string">"transactionTag"</span><span class="token punctuation">,</span> <span class="token string">"msg-"</span> <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"Hello RocketMQ "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span>
                                <span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>RemotingHelper<span class="token punctuation">.</span>DEFAULT_CHARSET<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                SendResult sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">sendMessageInTransaction</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span>
                        null<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// System.out.printf("%s%n", sendResult);</span>
                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MQClientException</span> <span class="token operator">|</span> UnsupportedEncodingException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="2）实现事务的监听接口"><a href="#2）实现事务的监听接口" class="headerlink" title="2）实现事务的监听接口"></a>2）实现事务的监听接口</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionListenerImpl</span> <span class="token keyword">implements</span> <span class="token class-name">TransactionListener</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger transactionIndex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger checkTimes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> ConcurrentHashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> localTrans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 本地事务的执行逻辑
     *
     * @param msg
     * @param arg
     * @return
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> LocalTransactionState <span class="token function">executeLocalTransaction</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span>
            Object arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        LocalTransactionState state<span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行本地事务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"msg-4"</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">getKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            state <span class="token operator">=</span> LocalTransactionState<span class="token punctuation">.</span>COMMIT_MESSAGE<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"msg-5"</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">getKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            state <span class="token operator">=</span> LocalTransactionState<span class="token punctuation">.</span>ROLLBACK_MESSAGE<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            state <span class="token operator">=</span> LocalTransactionState<span class="token punctuation">.</span>UNKNOW<span class="token punctuation">;</span>
            localTrans<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">getKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> transactionIndex<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"executeLocalTransaction: "</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span><span class="token function">getKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token operator">+</span> <span class="token string">",excute state: "</span> <span class="token operator">+</span> state <span class="token operator">+</span> <span class="token string">",current time: "</span>
                <span class="token operator">+</span> DateUtils<span class="token punctuation">.</span><span class="token function">formatLocalDateTime</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> state<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 回查本地事务的代码实现
     *
     * @param msg
     * @return
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> LocalTransactionState <span class="token function">checkLocalTransaction</span><span class="token punctuation">(</span>MessageExt msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"checkLocalTransaction message key: "</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span><span class="token function">getKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token operator">+</span> <span class="token string">",current time: "</span>
                <span class="token operator">+</span> DateUtils<span class="token punctuation">.</span><span class="token function">formatLocalDateTime</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Integer index <span class="token operator">=</span> localTrans<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">getKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">switch</span> <span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"check result: unknow, 回查次数："</span>
                            <span class="token operator">+</span> checkTimes<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> LocalTransactionState<span class="token punctuation">.</span>UNKNOW<span class="token punctuation">;</span>
                <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"check result: commit message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> LocalTransactionState<span class="token punctuation">.</span>COMMIT_MESSAGE<span class="token punctuation">;</span>
                <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"check result: rollback message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> LocalTransactionState<span class="token punctuation">.</span>ROLLBACK_MESSAGE<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> LocalTransactionState<span class="token punctuation">.</span>COMMIT_MESSAGE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="3）事务消息执行结果"><a href="#3）事务消息执行结果" class="headerlink" title="3）事务消息执行结果"></a>3）事务消息执行结果</h4><p>msg-4执行本地事务成功</p>
<p>msg-5执行本地事务失败，回滚事务</p>
<p>msg-1执行本地事务失败，默认回查15次，每一次间隔60秒</p>
<p>msg-2执行本地事务失败，回查1次，执行成功</p>
<p>msg-3执行本地事务失败，回查1次，回滚事务</p>
<h3 id="6-3-使用限制"><a href="#6-3-使用限制" class="headerlink" title="6.3 使用限制"></a>6.3 使用限制</h3><ol>
<li>事务消息不支持延时消息和批量消息。</li>
<li>为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为 15 次，但是用户可以通过 Broker 配置文件的 <code>transactionCheckMax</code>参数来修改此限制。如果已经检查某条消息超过 N 次的话（ N = <code>transactionCheckMax</code> ） 则 Broker 将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写 <code>AbstractTransactionCheckListener</code> 类来修改这个行为。</li>
<li>事务消息将在 Broker 配置文件中的参数 transactionMsgTimeout 这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_IN_SECONDS 来改变这个限制，该参数优先于 <code>transactionMsgTimeout</code> 参数。</li>
<li>事务性消息可能不止一次被检查或消费。</li>
<li>提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制。</li>
<li>事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者。</li>
</ol>
]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ高级功能</title>
    <url>/2021/04/30/rocketmq-gao-ji-gong-neng/</url>
    <content><![CDATA[<h1 id="RocketMQ高级功能"><a href="#RocketMQ高级功能" class="headerlink" title="RocketMQ高级功能"></a>RocketMQ高级功能</h1><h2 id="1-刷盘机制"><a href="#1-刷盘机制" class="headerlink" title="1. 刷盘机制"></a>1. 刷盘机制</h2><p>RocketMQ的消息是存储到磁盘上的，这样既能保证断电后恢复， 又可以让存储的消息量超出内存的限制。RocketMQ为了提高性能，会尽可能地保证磁盘的顺序写。消息在通过Producer写入RocketMQ的时 候，有两种写磁盘方式，分布式同步刷盘和异步刷盘。</p>
<p><img src="https://img-blog.csdnimg.cn/20210430145056233.png" alt></p>
<h3 id="1-1-同步刷盘"><a href="#1-1-同步刷盘" class="headerlink" title="1.1 同步刷盘"></a>1.1 同步刷盘</h3><p>在返回写成功状态时，消息已经被写入磁盘。具体流程是，消息写入内存的PAGECACHE后，立刻通知刷盘线程刷盘， 然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写 成功的状态。</p>
<h3 id="1-2-异步刷盘"><a href="#1-2-异步刷盘" class="headerlink" title="1.2 异步刷盘"></a>1.2 异步刷盘</h3><p>在返回写成功状态时，消息可能只是被写入了内存的PAGECACHE，写操作的返回快，吞吐量大；当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。（所以如果消息还没有刷入到磁盘里面，但是broker宕机了。那么消息就会丢失。）</p>
<h3 id="1-3-配置"><a href="#1-3-配置" class="headerlink" title="1.3 配置"></a>1.3 配置</h3><p><strong>同步刷盘还是异步刷盘，都是通过Broker配置文件里的flushDiskType 参数设置的，这个参数被配置成SYNC_FLUSH、ASYNC_FLUSH中的 一个。</strong></p>
<h2 id="2-高可用机制"><a href="#2-高可用机制" class="headerlink" title="2. 高可用机制"></a>2. 高可用机制</h2><p><img src="https://img-blog.csdnimg.cn/20210430145158597.jpg" alt></p>
<p>RocketMQ分布式集群是通过Master和Slave的配合达到高可用性的。</p>
<p>Master和Slave的区别：在Broker的配置文件中，参数 brokerId的值为0表明这个Broker是Master，大于0表明这个Broker是 Slave，同时brokerRole参数也会说明这个Broker是Master还是Slave。</p>
<p>Master角色的Broker支持读和写，Slave角色的Broker仅支持读，也就是 Producer只能和Master角色的Broker连接写入消息；Consumer可以连接 Master角色的Broker，也可以连接Slave角色的Broker来读取消息。</p>
<h3 id="2-1-消息消费高可用"><a href="#2-1-消息消费高可用" class="headerlink" title="2.1 消息消费高可用"></a>2.1 消息消费高可用</h3><p>在Consumer的配置文件中，并不需要设置是从Master读还是从Slave 读，当Master不可用或者繁忙的时候，Consumer会被自动切换到从Slave 读。有了自动切换Consumer这种机制，当一个Master角色的机器出现故障后，Consumer仍然可以从Slave读取消息，不影响Consumer程序。这就达到了消费端的高可用性。</p>
<h3 id="2-2-消息发送高可用"><a href="#2-2-消息发送高可用" class="headerlink" title="2.2 消息发送高可用"></a>2.2 消息发送高可用</h3><p>在创建Topic的时候，把Topic的多个Message Queue创建在多个Broker组上（相同Broker名称，不同 brokerId的机器组成一个Broker组），这样当一个Broker组的Master不可 用后，其他组的Master仍然可用，Producer仍然可以发送消息。 RocketMQ目前还不支持把Slave自动转成Master，如果机器资源不足， 需要把Slave转成Master，则要手动停止Slave角色的Broker，更改配置文 件，用新的配置文件启动Broker。</p>
<p><img src="https://img-blog.csdnimg.cn/2021043014534273.jpg" alt></p>
<h3 id="2-3-消息主从复制"><a href="#2-3-消息主从复制" class="headerlink" title="2.3 消息主从复制"></a>2.3 消息主从复制</h3><p>如果一个Broker组有Master和Slave，消息需要从Master复制到Slave 上，有同步和异步两种复制方式。</p>
<h4 id="2-3-1-同步复制"><a href="#2-3-1-同步复制" class="headerlink" title="2.3.1 同步复制"></a>2.3.1 同步复制</h4><p>同步复制方式是等Master和Slave均写 成功后才反馈给客户端写成功状态；</p>
<p>在同步复制方式下，如果Master出故障， Slave上有全部的备份数据，容易恢复，但是同步复制会增大数据写入 延迟，降低系统吞吐量。</p>
<h4 id="2-3-2-异步复制"><a href="#2-3-2-异步复制" class="headerlink" title="2.3.2 异步复制"></a>2.3.2 异步复制</h4><p>异步复制方式是只要Master写成功 即可反馈给客户端写成功状态。</p>
<p>在异步复制方式下，系统拥有较低的延迟和较高的吞吐量，但是如果Master出了故障，有些数据因为没有被写 入Slave，有可能会丢失；</p>
<h4 id="2-3-3-配置"><a href="#2-3-3-配置" class="headerlink" title="2.3.3 配置"></a>2.3.3 配置</h4><p>同步复制和异步复制是通过Broker配置文件里的brokerRole参数进行设置的，这个参数可以被设置成ASYNC_MASTER、 SYNC_MASTER、SLAVE三个值中的一个。</p>
<h4 id="2-3-4-总结"><a href="#2-3-4-总结" class="headerlink" title="2.3.4 总结"></a>2.3.4 总结</h4><p>实际应用中要结合业务场景，合理设置刷盘方式和主从复制方式， 尤其是SYNC_FLUSH方式，由于频繁地触发磁盘写动作，会明显降低 性能。通常情况下，应该把Master和Save配置成ASYNC_FLUSH的刷盘 方式，主从之间配置成SYNC_MASTER的复制方式，这样即使有一台 机器出故障，仍然能保证数据不丢，是个不错的选择。</p>
<h2 id="3-负载均衡机制"><a href="#3-负载均衡机制" class="headerlink" title="3. 负载均衡机制"></a>3. 负载均衡机制</h2><h3 id="3-1-Producer负载均衡"><a href="#3-1-Producer负载均衡" class="headerlink" title="3.1 Producer负载均衡"></a>3.1 Producer负载均衡</h3><p>Producer端，每个实例在发消息的时候，默认会轮询所有的message queue发送，以达到让消息平均落在不同的queue上。而由于queue可以散落在不同的broker，所以消息就发送到不同的broker下，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210507160454111.png" alt></p>
<p>图中箭头线条上的标号代表顺序，发布方会把第一条消息发送至 Queue 0，然后第二条消息发送至 Queue 1，以此类推。</p>
<h3 id="3-2-Consumer负载均衡"><a href="#3-2-Consumer负载均衡" class="headerlink" title="3.2 Consumer负载均衡"></a>3.2 Consumer负载均衡</h3><h4 id="1）集群模式"><a href="#1）集群模式" class="headerlink" title="1）集群模式"></a>1）集群模式</h4><p>在集群消费模式下，每条消息只需要投递到订阅这个topic的Consumer Group下的一个实例即可。RocketMQ采用主动拉取的方式拉取并消费消息，在拉取的时候需要明确指定拉取哪一条message queue。</p>
<p>而每当实例的数量有变更，都会触发一次所有实例的负载均衡，这时候会按照queue的数量和实例的数量平均分配queue给每个实例。</p>
<p>默认的分配算法是AllocateMessageQueueAveragely，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210430145518345.png" alt></p>
<p>还有另外一种平均的算法是AllocateMessageQueueAveragelyByCircle，也是平均分摊每一条queue，只是以环状轮流分queue的形式，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210430145541347.png" alt></p>
<p>需要注意的是，集群模式下，queue都是只允许分配只一个实例，这是由于如果多个实例同时消费一个queue的消息，由于拉取哪些消息是consumer主动控制的，那样会导致同一个消息在不同的实例下被消费多次，所以算法上都是一个queue只分给一个consumer实例，一个consumer实例可以允许同时分到不同的queue。</p>
<p>通过增加consumer实例去分摊queue的消费，可以起到水平扩展的消费能力的作用。而有实例下线的时候，会重新触发负载均衡，这时候原来分配到的queue将分配到其他实例上继续消费。</p>
<p>但是如果consumer实例的数量比message queue的总数量还多的话，多出来的consumer实例将无法分到queue，也就无法消费到消息，也就无法起到分摊负载的作用了。所以需要控制让queue的总数量大于等于consumer的数量。</p>
<h4 id="2）广播模式"><a href="#2）广播模式" class="headerlink" title="2）广播模式"></a>2）广播模式</h4><p>由于广播模式下要求一条消息需要投递到一个消费组下面所有的消费者实例，所以也就没有消息被分摊消费的说法。</p>
<p>在实现上，其中一个不同就是在consumer分配queue的时候，所有consumer都分到所有的queue。</p>
<p><img src="https://img-blog.csdnimg.cn/20210430145602786.png" alt></p>
<h2 id="4-消息重试"><a href="#4-消息重试" class="headerlink" title="4. 消息重试"></a>4. 消息重试</h2><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span>
<span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@RocketMQMessageListener</span><span class="token punctuation">(</span>topic <span class="token operator">=</span> <span class="token string">"CSS"</span><span class="token punctuation">,</span> selectorExpression <span class="token operator">=</span> <span class="token string">"ORDER_CANCEL"</span><span class="token punctuation">,</span> consumerGroup <span class="token operator">=</span> <span class="token string">"springboot-mq-consumer-1"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestConsumer</span> <span class="token keyword">implements</span> <span class="token class-name">RocketMQListener</span><span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Receive message："</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ServiceException</span><span class="token punctuation">(</span><span class="token string">"200"</span><span class="token punctuation">,</span> <span class="token string">"消息消费失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>消费者如果消费某个消息失败，比如上面示例中的消费者，消费消息失败，则会重试消费消息。</p>
<h3 id="4-1-顺序消息的重试"><a href="#4-1-顺序消息的重试" class="headerlink" title="4.1 顺序消息的重试"></a>4.1 顺序消息的重试</h3><p>对于顺序消息，当消费者消费消息失败后，消息队列 RocketMQ 会自动不断进行消息重试（每次间隔时间为 1 秒），这时，应用会出现消息消费被阻塞的情况。因此，在使用顺序消息时，务必保证应用能够及时监控并处理消费失败的情况，避免阻塞现象的发生。</p>
<h3 id="4-2-无序消息的重试"><a href="#4-2-无序消息的重试" class="headerlink" title="4.2 无序消息的重试"></a>4.2 无序消息的重试</h3><p>对于无序消息（普通、定时、延时、事务消息），当消费者消费消息失败时，您可以通过设置返回状态达到消息重试的结果。</p>
<p>无序消息的重试只针对集群消费方式生效；广播方式不提供失败重试特性，即消费失败后，失败消息不再重试，继续消费新的消息。</p>
<h4 id="1）重试次数"><a href="#1）重试次数" class="headerlink" title="1）重试次数"></a>1）重试次数</h4><p>消息队列 RocketMQ 默认允许每条消息最多重试 16 次，每次重试的间隔时间如下：</p>
<table>
<thead>
<tr>
<th align="center">第几次重试</th>
<th align="center">与上次重试的间隔时间</th>
<th align="center">第几次重试</th>
<th align="center">与上次重试的间隔时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">10 秒</td>
<td align="center">9</td>
<td align="center">7 分钟</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">30 秒</td>
<td align="center">10</td>
<td align="center">8 分钟</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1 分钟</td>
<td align="center">11</td>
<td align="center">9 分钟</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">2 分钟</td>
<td align="center">12</td>
<td align="center">10 分钟</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">3 分钟</td>
<td align="center">13</td>
<td align="center">20 分钟</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">4 分钟</td>
<td align="center">14</td>
<td align="center">30 分钟</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">5 分钟</td>
<td align="center">15</td>
<td align="center">1 小时</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">6 分钟</td>
<td align="center">16</td>
<td align="center">2 小时</td>
</tr>
</tbody></table>
<p>如果消息重试 16 次后仍然失败，消息将不再投递。如果严格按照上述重试时间间隔计算，某条消息在一直消费失败的前提下，将会在接下来的 4 小时 46 分钟之内进行 16 次重试，超过这个时间范围消息将不再重试投递。</p>
<p><strong>注意：</strong> 一条消息无论重试多少次，这些重试消息的 Message ID 不会改变。</p>
<h4 id="2）配置方式"><a href="#2）配置方式" class="headerlink" title="2）配置方式"></a>2）配置方式</h4><p><strong>消费失败后，重试配置方式</strong></p>
<p>集群消费方式下，消息消费失败后期望消息重试，需要在消息监听器接口的实现中明确进行配置（三种方式任选一种）：</p>
<ul>
<li>返回 Action.ReconsumeLater （推荐）</li>
<li>返回 Null</li>
<li>抛出异常</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageListenerImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MessageListener</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Action <span class="token function">consume</span><span class="token punctuation">(</span>Message message<span class="token punctuation">,</span> ConsumeContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//处理消息</span>
        <span class="token function">doConsumeMessage</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//方式1：返回 Action.ReconsumeLater，消息将重试</span>
        <span class="token keyword">return</span> Action<span class="token punctuation">.</span>ReconsumeLater<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//方式2：返回 null，消息将重试</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//方式3：直接抛出异常， 消息将重试</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Consumer Message exceotion"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>消费失败后，不重试配置方式</strong></p>
<p>集群消费方式下，消息失败后期望消息不重试，需要捕获消费逻辑中可能抛出的异常，最终返回 Action.CommitMessage，此后这条消息将不会再重试。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageListenerImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MessageListener</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Action <span class="token function">consume</span><span class="token punctuation">(</span>Message message<span class="token punctuation">,</span> ConsumeContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token function">doConsumeMessage</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//捕获消费逻辑中的所有异常，并返回 Action.CommitMessage;</span>
            <span class="token keyword">return</span> Action<span class="token punctuation">.</span>CommitMessage<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//消息处理正常，直接返回 Action.CommitMessage;</span>
        <span class="token keyword">return</span> Action<span class="token punctuation">.</span>CommitMessage<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>自定义消息最大重试次数</strong></p>
<p>消息队列 RocketMQ 允许 Consumer 启动的时候设置最大重试次数，重试时间间隔将按照如下策略：</p>
<ul>
<li>最大重试次数小于等于 16 次，则重试时间间隔同上表描述。</li>
<li>最大重试次数大于 16 次，超过 16 次的重试时间间隔均为每次 2 小时。</li>
</ul>
<pre class=" language-java"><code class="language-java">Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//配置对应 Group ID 的最大消息重试次数为 20 次</span>
properties<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>PropertyKeyConst<span class="token punctuation">.</span>MaxReconsumeTimes<span class="token punctuation">,</span><span class="token string">"20"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Consumer consumer <span class="token operator">=</span>ONSFactory<span class="token punctuation">.</span><span class="token function">createConsumer</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li>消息最大重试次数的设置对相同 Group ID 下的所有 Consumer 实例有效。</li>
<li>如果只对相同 Group ID 下两个 Consumer 实例中的其中一个设置了 MaxReconsumeTimes，那么该配置对两个 Consumer 实例均生效。</li>
<li>配置采用覆盖的方式生效，即最后启动的 Consumer 实例会覆盖之前的启动实例的配置</li>
</ul>
<p><strong>获取消息重试次数</strong></p>
<p>消费者收到消息后，可按照如下方式获取消息的重试次数：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageListenerImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MessageListener</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Action <span class="token function">consume</span><span class="token punctuation">(</span>Message message<span class="token punctuation">,</span> ConsumeContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//获取消息的重试次数</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getReconsumeTimes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Action<span class="token punctuation">.</span>CommitMessage<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="5-死信队列"><a href="#5-死信队列" class="headerlink" title="5. 死信队列"></a>5. 死信队列</h2><p> 当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 RocketMQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p>
<p>在消息队列 RocketMQ 中，这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。</p>
<h3 id="5-1-死信特性"><a href="#5-1-死信特性" class="headerlink" title="5.1 死信特性"></a>5.1 死信特性</h3><p>死信消息具有以下特性</p>
<ul>
<li>不会再被消费者正常消费。</li>
<li>有效期与正常消息相同，均为 3 天，3 天后会被自动删除。因此，请在死信消息产生后的 3 天内及时处理。</li>
</ul>
<p>死信队列具有以下特性：</p>
<ul>
<li><p>一个死信队列对应一个 Group ID， 而不是对应单个消费者实例。</p>
</li>
<li><p>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列。</p>
</li>
<li><p>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic。</p>
</li>
</ul>
<p>死信队列可以在RocketMQ控制台里面进行查看</p>
<p>一条消息进入死信队列，意味着某些因素导致消费者无法正常消费该消息，因此，通常需要您对其进行特殊处理。排查可疑因素并解决问题后，可以在消息队列 RocketMQ 控制台重新发送该消息，让消费者重新消费一次。</p>
<h2 id="6-消费幂等"><a href="#6-消费幂等" class="headerlink" title="6. 消费幂等"></a>6. 消费幂等</h2><p>消息队列 RocketMQ 消费者在接收到消息以后，有必要根据业务上的唯一 Key 对消息做幂等处理的必要性。</p>
<h3 id="6-1-消费幂等的必要性"><a href="#6-1-消费幂等的必要性" class="headerlink" title="6.1 消费幂等的必要性"></a>6.1 消费幂等的必要性</h3><p>在互联网应用中，尤其在网络不稳定的情况下，消息队列 RocketMQ 的消息有可能会出现重复，这个重复简单可以概括为以下情况：</p>
<ul>
<li><p>发送时消息重复</p>
<p>当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致服务端对客户端应答失败。 如果此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p>
</li>
<li><p>投递时消息重复</p>
<p>消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。 为了保证消息至少被消费一次，消息队列 RocketMQ 的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且 Message ID 也相同的消息。</p>
</li>
<li><p>负载均衡时消息重复（包括但不限于网络抖动、Broker 重启以及订阅方应用重启）</p>
<p>当消息队列 RocketMQ 的 Broker 或客户端重启、扩容或缩容时，会触发 Rebalance，此时消费者可能会收到重复消息。</p>
</li>
</ul>
<h3 id="6-2-处理方式"><a href="#6-2-处理方式" class="headerlink" title="6.2 处理方式"></a>6.2 处理方式</h3><p>RocketMQ虽然对于每一条消息都生成了一个消息Message ID。但是 Message ID 有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以 Message ID 作为处理依据。 最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息 Key 进行设置：</p>
<pre class=" language-java"><code class="language-java">Message message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
message<span class="token punctuation">.</span><span class="token function">setKey</span><span class="token punctuation">(</span><span class="token string">"ORDERID_100"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
SendResult sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>订阅方收到消息时可以根据消息的 Key 进行幂等处理：</p>
<pre class=" language-java"><code class="language-java">consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"ons_test"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> Action <span class="token function">consume</span><span class="token punctuation">(</span>Message message<span class="token punctuation">,</span> ConsumeContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String key <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">// 根据业务唯一标识的 key 做幂等处理</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>alertmanager安装教程</title>
    <url>/2020/07/01/alertmanager-an-zhuang/</url>
    <content><![CDATA[<h2 id="1-下载Alertmanager"><a href="#1-下载Alertmanager" class="headerlink" title="1. 下载Alertmanager"></a>1. 下载Alertmanager</h2><p>alertmanager官方网站下载<br><a href="https://prometheus.io/download/#alertmanager" target="_blank" rel="noopener">https://prometheus.io/download/#alertmanager</a></p>
<pre><code>wget https://github.com/prometheus/alertmanager/releases/download/v0.17.0/alertmanager-0.17.0.linux-amd64.tar.gz
tar xvf alertmanager-0.17.0.linux-amd64.tar.gz
mv alertmanager-0.17.0.linux-amd64 /usr/local/alertmanager</code></pre><h2 id="2-启动Alertmanager"><a href="#2-启动Alertmanager" class="headerlink" title="2. 启动Alertmanager"></a>2. 启动Alertmanager</h2><p>linux 中启动alertmanager命令<br>cd进入到alertmanager根目录</p>
<pre><code>./alertmanager --config.file=alertmanager.yml</code></pre><h2 id="3-查看Alertmanager运行状态"><a href="#3-查看Alertmanager运行状态" class="headerlink" title="3. 查看Alertmanager运行状态"></a>3. 查看Alertmanager运行状态</h2><p>Alertmanager启动后可以通过9093端口访问，<a href="http://ip:9093" target="_blank" rel="noopener">http://ip:9093</a></p>
<h2 id="4-Prometheus中配置Alertmanager"><a href="#4-Prometheus中配置Alertmanager" class="headerlink" title="4. Prometheus中配置Alertmanager"></a>4. Prometheus中配置Alertmanager</h2><p><strong>修改prometheus.yml</strong>,配置alertmanager的地址。</p>
<pre><code>alerting:
 alertmanagers:
 - static_configs:
   - targets: [&quot;localhost:9093&quot;] </code></pre><p>至此。prometheus产生告警后将会发送给prometheus。<br>注意点：</p>
<ol>
<li>需要配置告警规则。</li>
<li>alertmanager配置文件需要配置收到告警后对告警的处理方式。<br>这个在本专栏的其他文章中讲解。</li>
</ol>
]]></content>
      <categories>
        <category>prometheus</category>
      </categories>
      <tags>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>arthas常用命令记录</title>
    <url>/2022/09/05/arthas-chang-yong-ming-ling-ji-lu/</url>
    <content><![CDATA[<h1 id="arthas常用命令记录-md"><a href="#arthas常用命令记录-md" class="headerlink" title="arthas常用命令记录.md"></a>arthas常用命令记录.md</h1><h2 id="下载arthas"><a href="#下载arthas" class="headerlink" title="下载arthas"></a>下载arthas</h2><pre><code>curl -O https://arthas.aliyun.com/arthas-boot.jar</code></pre><h2 id="启动arthas"><a href="#启动arthas" class="headerlink" title="启动arthas"></a>启动arthas</h2><pre><code>java -jar arthas-boot.jar</code></pre><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ol>
<li><p><strong>arthas后台异步任务</strong></p>
<ol>
<li><p>arthas使用&amp;在后台异步执行任务</p>
<pre><code>trace Test t &amp;</code></pre></li>
<li><p>通过jobs查看后台异步任务</p>
<pre><code>jobs</code></pre></li>
</ol>
</li>
<li><p><strong>dashboard：查看当前系统的实时数据面板</strong></p>
<pre class=" language-text"><code class="language-text">dashboard</code></pre>
</li>
<li><p><strong>memory：查看 JVM 内存信息。</strong></p>
<pre><code>memory</code></pre></li>
<li><p><strong>sysenv查看当前JVM的环境属性（System Environment Variables），支持通过<code>TAB</code>键自动补全</strong></p>
<pre><code>sysenv</code></pre></li>
<li><p><strong>sysprop查看当前 JVM 的系统属性(System Property)，支持通过<code>TAB</code>键自动补全</strong></p>
<p><strong>此命令可以查看配置文件的信息</strong></p>
<pre><code>sysprop</code></pre></li>
<li><p><strong>thread：查看当前线程信息，查看线程的堆栈</strong></p>
<ol>
<li><p>查看当前最忙的前 N 个线程并打印堆栈</p>
<pre><code>thread -n 3</code></pre></li>
<li><p>thread id, 显示指定线程的运行堆栈</p>
<pre><code>thread 1</code></pre></li>
<li><p>thread -b, 找出当前阻塞其他线程的线程</p>
<pre><code>thread -b</code></pre></li>
</ol>
</li>
<li><p><strong>jad：反编译指定已加载类的源码</strong></p>
<pre><code>jad --source-only java.lang.String</code></pre></li>
<li><p><strong>monitor：方法执行监控</strong></p>
<pre><code>monitor com.jf.redisstudy.controller.HelloController getName  -n 10  --cycle 10 &amp;</code></pre></li>
<li><p><strong>stack：输出当前方法被调用的调用路径</strong></p>
<pre><code>stack com.jf.redisstudy.controller.HelloController hello  -n 5 </code></pre></li>
<li><p><strong>trace：方法内部调用路径，并输出方法路径上的每个节点上耗时</strong></p>
<pre><code>trace com.jf.redisstudy.controller.HelloController hello  -n 5 --skipJDKMethod false &amp;</code></pre></li>
<li><p><strong>tt：方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</strong></p>
<p>tt命令可以用在类上，也可以用在方法上</p>
<p>用法方法上：</p>
<pre><code>tt -t com.jf.redisstudy.controller.HelloController hello -n 5 &amp;</code></pre><p>当你用 tt 记录了一大片的时间片段之后，你希望能从中筛选出自己需要的时间片段，这个时候你就需要对现有记录进行检索。</p>
<pre><code>tt -l</code></pre><p>查看调用信息</p>
<pre><code>tt -i 索引id</code></pre><p>重做一次调用</p>
<pre><code>tt -i 索引id -p</code></pre></li>
<li><p><strong>watch：方法执行出入参查看</strong></p>
<pre><code>watch com.jf.redisstudy.controller.HelloController hello &#39;{params,returnObj,throwExp}&#39;  -n 5  -x 3 &amp;</code></pre></li>
<li><p><strong>json格式查看结果</strong></p>
<pre><code>options json-format true</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>arthas</category>
      </categories>
      <tags>
        <tag>arthas</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot使用jetcache本地缓存</title>
    <url>/2020/05/12/springboot-shi-yong-jetcache-ben-di-huan-cun/</url>
    <content><![CDATA[<h1 id="SpringBoot使用jetcache本地缓存"><a href="#SpringBoot使用jetcache本地缓存" class="headerlink" title="SpringBoot使用jetcache本地缓存"></a>SpringBoot使用jetcache本地缓存</h1><h2 id="引入mavne依赖"><a href="#引入mavne依赖" class="headerlink" title="引入mavne依赖"></a>引入mavne依赖</h2><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.alicp.jetcache&lt;/groupId&gt;
    &lt;artifactId&gt;jetcache-starter-redis&lt;/artifactId&gt;
    &lt;version&gt;2.6.4&lt;/version&gt;
&lt;/dependency&gt;</code></pre><h2 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h2><pre><code># cache 状态监控刷新时间
jetcache.statIntervalMinutes=1
jetcache.areaInCacheName=false
# 进程内的并发访问保护默认开关
jetcache.penetrationProtect=true
jetcache.local.default.type=caffeine
jetcache.local.default.keyConvertor=fastjson
# 默认单个 method cache 支持数量100个，需要具体看服务情况调整
jetcache.local.default.limit=100
# 缓存失效时间，全局默认10s
jetcache.local.default.expireAfterWriteInMillis=10000
</code></pre><h2 id="开启缓存"><a href="#开启缓存" class="headerlink" title="开启缓存"></a>开启缓存</h2><p>在启动类上添加@EnableMethodCache注解，扫描指定包下面的@Cached注解，使缓存生效。</p>
<p>注意：jetcache是基于AOP的，所以需要放在public方法上，并且不能是本类方法调用。</p>
<pre><code>@SpringBootApplication
@EnableMethodCache(basePackages = &quot;xxx.xxx&quot;)
public class RedisSpringBootMain {
    public static void main(String[] args) {
        SpringApplication.run(RedisSpringBootMain.class, args);
    }
}</code></pre><h2 id="缓存名称删除规则"><a href="#缓存名称删除规则" class="headerlink" title="缓存名称删除规则"></a>缓存名称删除规则</h2><p>AreaName+cacheName, cacheName 如果未指定，则通过类签名+函数签名+参数签名实现</p>
<h2 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h2><p>key支持spel表达式，可自定义key的生成规则。不指定key，则使用默认规则</p>
<pre><code>   /**
     * 单个key
     */
    @PostMapping(&quot;/jetCacheGet&quot;)
    @Cached(cacheType = CacheType.LOCAL, expire = 6)
    public BaseResult&lt;List&lt;UserDTO&gt;&gt; jetCacheGet(@RequestBody String bizShowId) {
        log.info(&quot;从数据库获得数据&quot;);
        return BaseResult.success(UserDTO.getUserList());
    }</code></pre><pre><code>     /**
     * 对象
     */
    @PostMapping(&quot;/jetCacheGet2&quot;)
    @Cached(cacheType = CacheType.LOCAL, expire = 6)
    public BaseResult&lt;List&lt;UserDTO&gt;&gt; jetCacheGet2(@RequestBody UserDTO userDTO) {
        log.info(&quot;从数据库获得数据&quot;);
        return BaseResult.success(UserDTO.getUserList());
    }
</code></pre><pre><code>    /**
     * 集合排序
     */
    @PostMapping(&quot;/jetCacheGet3&quot;)
    @Cached(cacheType = CacheType.LOCAL, key = &quot;T(com.jf.common.utils.jetcache.JetCacheUtils).sorted(#bizShowIdList)&quot;, expire = 6)
    public BaseResult&lt;List&lt;UserDTO&gt;&gt; jetCacheGet3(@RequestBody List&lt;String&gt; bizShowIdList) {
        log.info(&quot;从数据库获得数据&quot;);
        return BaseResult.success(UserDTO.getUserList());
    }</code></pre><pre><code>    /**
     * 集合对象排序
     */
    @PostMapping(&quot;/jetCacheGet4&quot;)
    @Cached(cacheType = CacheType.LOCAL, key = &quot;T(com.jf.common.utils.jetcache.JetCacheUtils).sorted(#UserDTO)&quot;, expire = 6)
    public BaseResult&lt;List&lt;UserDTO&gt;&gt; jetCacheGet4(@RequestBody List&lt;UserDTO&gt; userDTOList) {
        log.info(&quot;从数据库获得数据&quot;);
        return BaseResult.success(UserDTO.getUserList());
    }</code></pre>]]></content>
      <categories>
        <category>高性能缓存</category>
      </categories>
      <tags>
        <tag>jetcache</tag>
      </tags>
  </entry>
  <entry>
    <title>docker启动ElasticSearch</title>
    <url>/2022/08/03/docker-qi-dong-elasticsearch/</url>
    <content><![CDATA[<h1 id="docker启动ElasticSearch"><a href="#docker启动ElasticSearch" class="headerlink" title="docker启动ElasticSearch"></a>docker启动ElasticSearch</h1><ol>
<li><p>查询ElasticSearch镜像</p>
<pre><code>docker search elasticsearch</code></pre></li>
<li><p>从docker hub拉取最新镜像</p>
<pre><code>docker pull elasticsearch:7.6.0 </code></pre></li>
<li><p>查看ElasticSearch镜像</p>
<pre><code>docker images | grep elasticsearch</code></pre></li>
<li><p>配置文件</p>
<p>在/usr/java/docker文件夹下创建es的config文件夹，将docker中es的配置挂载在外部，当我们在linux虚拟机中修改es的配置文件时，就会同时修改docker中的es的配置</p>
<pre><code>mkdir -p /usr/java/docker/elasticsearch/config</code></pre><p>在/usr/java/docker文件夹下创建es的data文件夹</p>
<pre><code>mkdir -p /usr/java/docker/elasticsearch/data</code></pre><p>[http.host:0.0.0.0]允许任何远程机器访问es，并将其写入es的配置文件中</p>
<pre><code>echo &quot;http.host: 0.0.0.0&quot; &gt;&gt; /usr/java/docker/elasticsearch/config/elasticsearch.yml</code></pre><p>查看配置文件</p>
<pre><code>cat /usr/java/docker/elasticsearch/config/elasticsearch.yml</code></pre><p>保证权限问题</p>
<pre><code>chmod -R 777 /usr/java/docker/elasticsearch</code></pre></li>
</ol>
<ol start="5">
<li><p>使用docker运行ElasticSearch</p>
<pre><code>docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \
-e &quot;discovery.type=single-node&quot; \
-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx128m&quot; \
-v /usr/java/docker/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \
-v /usr/java/docker/elasticsearch/data:/usr/share/elasticsearch/data \
-v /usr/java/docker/elasticsearch/plugins:/usr/share/elasticsearch/plugins \
-d elasticsearch:7.6.0</code></pre><blockquote>
<p>命令解释说明：</p>
<p>docker run –name elasticsearch 创建一个es容器并起一个名字<br>-p 9200:9200 将linux的9200端口映射到docker容器的9200端口，用来给es发送http请求<br>-p 9300:9300 9300是es在分布式集群状态下节点之间的通信端口<br>-e 指定jvm内存，当前es以单节点模式运行<br>-v 挂载命令，将虚拟机中的路径和docker中的路径进行关联<br>-d 后台启动服务</p>
</blockquote>
<blockquote>
<p>注意：ES_JAVA_OPTS非常重要，指定开发时es运行时的最小和最大内存占用为64M和128M，否则就    会占用全部可用内存</p>
</blockquote>
</li>
<li><p>查看是否运行成功</p>
<pre><code>docker ps | grep elasticsearch</code></pre></li>
<li><p>查看启动日志</p>
<pre><code>docker logs elasticsearch</code></pre></li>
<li><p>在浏览器地址栏访问<a href="http://ip:9200/，可以看到" target="_blank" rel="noopener">http://ip:9200/，可以看到</a> es 启动成功后返回类似下面的数据</p>
<pre><code>{
  &quot;name&quot;: &quot;3717e262d33f&quot;,
  &quot;cluster_name&quot;: &quot;elasticsearch&quot;,
  &quot;cluster_uuid&quot;: &quot;njGUk4ruRDSQHT4xZTzB3A&quot;,
  &quot;version&quot;: {
    &quot;number&quot;: &quot;7.6.0&quot;,
    &quot;build_flavor&quot;: &quot;default&quot;,
    &quot;build_type&quot;: &quot;docker&quot;,
    &quot;build_hash&quot;: &quot;7f634e9f44834fbc12724506cc1da681b0c3b1e3&quot;,
    &quot;build_date&quot;: &quot;2020-02-06T00:09:00.449973Z&quot;,
    &quot;build_snapshot&quot;: false,
    &quot;lucene_version&quot;: &quot;8.4.0&quot;,
    &quot;minimum_wire_compatibility_version&quot;: &quot;6.8.0&quot;,
    &quot;minimum_index_compatibility_version&quot;: &quot;6.0.0-beta1&quot;
  },
  &quot;tagline&quot;: &quot;You Know, for Search&quot;
}</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker启动Canal</title>
    <url>/2022/09/07/docker-qi-dong-canal/</url>
    <content><![CDATA[<h1 id="docker启动Canal"><a href="#docker启动Canal" class="headerlink" title="docker启动Canal"></a>docker启动Canal</h1><p>备注：该文章暂时还有点问题，请勿阅读。</p>
<h2 id="一、安装MySQL："><a href="#一、安装MySQL：" class="headerlink" title="一、安装MySQL："></a>一、安装MySQL：</h2><p>参考文章：<a href="https://javacode.cc/2020/05/22/docker-qi-dong-mysql/" target="_blank" rel="noopener">https://javacode.cc/2020/05/22/docker-qi-dong-mysql/</a></p>
<ol>
<li><p>查看是否开启biglog</p>
<pre><code>show variables like &#39;log_bin&#39;;</code></pre></li>
<li><p>修改mysql配置文件my.cnf，同步biglog日志,并重启MySQL</p>
<pre><code># 打开binlog
log-bin=mysql-bin
# # 选择ROW(行)模式
binlog-format=ROW
# # 配置MySQL replaction需要定义，不要和canal的slaveId重复
server_id=1</code></pre></li>
<li><p>查看binlog是否生效</p>
<pre><code>#是否开启binlog
show variables like &#39;log_bin&#39;;

#查看biglog文件
show binary logs;

#查看主库状态
show master status;</code></pre></li>
<li><p>canal默认用户名和密码都是canal,给canal服务创建账号，并分配读的权限。</p>
<pre><code>#创建canal账号
CREATE USER canal IDENTIFIED BY &#39;canal&#39;;    
GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#39;canal&#39;@&#39;%&#39;;  
-- GRANT ALL PRIVILEGES ON *.* TO &#39;canal&#39;@&#39;%&#39; ;  

#刷新权限
FLUSH PRIVILEGES; 

#查看权限，获取直接通过sql查看：SELECT * FROM mysql.`user`;
show grants for &#39;canal&#39; 
</code></pre></li>
</ol>
<h2 id="二、安装canal"><a href="#二、安装canal" class="headerlink" title="二、安装canal"></a>二、安装canal</h2><ol>
<li><p>查询Canal镜像</p>
<pre><code>docker search canal</code></pre></li>
<li><p>从docker hub拉取最新镜像</p>
<pre><code>docker pull canal/canal-server:v1.1.6</code></pre></li>
<li><p>查看Canal镜像</p>
<pre><code>docker images | grep canal</code></pre></li>
<li><p>拉去完成后，先启动下canal，主要是为了从里面copy出配置文件</p>
<pre><code>#启动镜像 
docker run --name canal -d canal/canal-server:v1.1.6

#进入容器 查看配置文件路径
docker exec -it canal bash

#找到文件位置后 exit退出容器 将容器内部文件copy到外部
docker cp canal:/home/admin/canal-server/conf/canal.properties /usr/java/docker/canal
docker cp canal:/home/admin/canal-server/conf/example/instance.properties  /usr/java/docker/canal</code></pre></li>
</ol>
<ol start="5">
<li><p>修改instance.properties</p>
<pre><code>canal.instance.mysql.slaveId=1234
canal.instance.master.address=127.0.0.1:3306
</code></pre></li>
<li><p>修改canal.properties</p>
<pre><code></code></pre></li>
<li><p>修改完成后，将之前的canal容器关闭，重新起一个新的容器</p>
<ol>
<li><p>#强制移除容器</p>
<pre><code>docker rm -f canal</code></pre></li>
<li><p>#启动新的 这里-v是将外部的文件挂载到容器内部 这样就不用每次启动都要配置参数了</p>
<pre><code>docker run --name canal -p 11111:11111 -d \
-v /usr/java/docker/canal/instance.properties:/home/admin/canal-server/conf/example/instance.properties \
-v /usr/java/docker/canal/canal.properties:/home/admin/canal-server/conf/canal.properties \
-v /usr/java/docker/canal/logs/:/home/admin/canal-server/logs/ \
canal/canal-server:v1.1.6</code></pre></li>
</ol>
</li>
<li><p>查看是否运行成功</p>
<pre><code>docker ps | grep canal</code></pre></li>
<li><p>查看启动日志</p>
<pre><code>docker logs canal</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker启动nacos</title>
    <url>/2020/05/12/docker-qi-dong-nacos/</url>
    <content><![CDATA[<h1 id="docker启动nacos"><a href="#docker启动nacos" class="headerlink" title="docker启动nacos"></a>docker启动nacos</h1><h2 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h2><ol>
<li><p>查询nacos镜像</p>
<pre><code>docker search nacos</code></pre></li>
<li><p>从docker hub拉取最新镜像</p>
<pre><code>docker pull nacos/nacos-server</code></pre></li>
<li><p>查看nacos镜像</p>
<pre><code>docker images  | grep nacos</code></pre></li>
<li><p>使用docker运行nacos</p>
<pre><code>docker run -d -p 8848:8848 --env MODE=standalone  -e JVM_XMS=128m -e JVM_XMX=128m  --name nacos   nacos/nacos-server</code></pre><p>命令解释说明：</p>
<p>-p 8848:8848 端口映射：前表示主机部分，：后表示容器部分。</p>
<p>–name nacos 指定该容器名称，查看和进行操作都比较方便。</p>
<p>-e JVM_XMS=128m -e JVM_XMX=128m  给nacos分配jvm的内存。内存够的话可以不加这一行</p>
<p>–env MODE=standalone  单机模式启动</p>
</li>
<li><p>查看是否运行成功</p>
<pre><code>docker ps | grep nacos</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker启动MySQL</title>
    <url>/2020/05/22/docker-qi-dong-mysql/</url>
    <content><![CDATA[<h1 id="docker启动MySQL"><a href="#docker启动MySQL" class="headerlink" title="docker启动MySQL"></a>docker启动MySQL</h1><ol>
<li><p>查询mysql镜像</p>
<pre><code>docker search mysql</code></pre></li>
<li><p>从docker hub拉取镜像</p>
<pre><code>docker pull mysql:8.0.28</code></pre></li>
<li><p>查看mysql镜像</p>
<pre><code>docker images  | grep mysql</code></pre></li>
<li><p>复制文件</p>
<pre><code>#创建目录
mkdir -p /usr/java/docker/mysql/conf &amp;&amp; mkdir -p /usr/java/docker/mysql/data &amp;&amp; mkdir -p /usr/java/docker/mysql/logs

#启动容器，为了复制文件
docker run -p 3306:3306 --name mysql -d -e MYSQL_ROOT_PASSWORD=“123456” mysql:8.0.28

#复制文件
docker cp mysql:/etc/mysql/my.cnf /usr/java/docker/mysql/conf

#删除容器
docker rm -f mysql</code></pre></li>
<li><p>使用docker运行mysql</p>
<pre><code>docker run -p 3306:3306 --name mysql \
-v /usr/java/docker/mysql/logs:/var/log/mysql \
-v /usr/java/docker/mysql/data:/var/lib/mysql \
-v /usr/java/docker/mysql/conf:/etc/mysql/conf.d \
-e MYSQL_ROOT_PASSWORD=123456 \
--restart=always \
--privileged=true \
-d \
mysql:8.0.28</code></pre><p>命令解释说明：</p>
<p>-p 8848:8848 端口映射：前表示主机部分，：后表示容器部分。</p>
<p>–name mysql  指定该容器名称，查看和进行操作都比较方便。</p>
<p>-e MYSQL_ROOT_PASSWORD=123456：docker的MySQL默认的root密码是随机的，这是改一下默认的root用户密码</p>
<p>-d mysql:8.0.28   在后台运行mysql镜像产生的容器</p>
</li>
</ol>
<ol start="6">
<li><p>查看是否运行成功</p>
<pre><code>docker ps | grep mysql</code></pre></li>
</ol>
<ol start="7">
<li><p>通过navicat连接mysql出现2059的问题</p>
<p><strong>原因</strong>：8.0之后mysql更改了密码的加密规则，只要在命令窗口把加密方法改回去即可。</p>
<p><strong>解决办法</strong>：</p>
<ol>
<li><p>进入到docker容器里面的mysql</p>
<pre><code>docker exec -it mysql bash</code></pre></li>
<li><p>进去之后不用切换目录。直接输入下面的命令登录MySQL</p>
<pre><code>mysql -uroot -p123456</code></pre></li>
<li><p>然后运行以下SQL</p>
<pre><code>alter user &#39;root&#39;@&#39;%&#39; identified by &#39;123456&#39; password expire never;
alter user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;123456&#39;;
flush privileges;</code></pre></li>
<li><p>重新启动docker里面的mysql容器</p>
<pre><code>docker restart mysql</code></pre></li>
</ol>
</li>
</ol>
<ol start="8">
<li>通过navicat客户端重新连接即可</li>
</ol>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker启动redis</title>
    <url>/2020/05/12/docker-qi-dong-redis/</url>
    <content><![CDATA[<h1 id="docker启动redis"><a href="#docker启动redis" class="headerlink" title="docker启动redis"></a>docker启动redis</h1><ol>
<li><p>查询redis镜像</p>
<pre><code>docker search redis</code></pre></li>
<li><p>从docker hub拉取最新镜像</p>
<pre><code>docker pull redis:6.0</code></pre></li>
<li><p>查看redis镜像</p>
<pre><code>docker images | grep redis</code></pre></li>
<li><p>创建文件挂载目录</p>
<pre><code>mkdir /usr/java/docker/redis</code></pre><p>将默认的redis.conf配置放到这个目录下面。（该文件可以从网上找一下，下载下来）作为映射文件。注意下载对应版本的redis，解压将配置文件复制出来。</p>
<pre><code>http://download.redis.io/releases/</code></pre></li>
<li><p>修改redis.conf配置文件</p>
<ol>
<li><p>bind：默认情况bind=127.0.0.1，只能接受本机的访问请求，不写的情况下，无限制接受任何ip地址的访问，为了能够让除本机的其余服务器也能远程访问，将 bind 127.0.0.1 -::1注释掉</p>
<pre><code>#bind 127.0.0.1</code></pre></li>
<li><p>protected-mode：为了能够让除本机的其余服务器也能远程访问，将 protected-mode yes 修改为 protected-mode no</p>
<pre><code>protected-mode no</code></pre></li>
<li><p>daemonize：是否为后台进程，设置为yes，守护进程，后台启动</p>
<pre><code>daemonize yes</code></pre></li>
<li><p>appendonly：是否开启aof持久化，设置为yes</p>
<pre><code>appendonly yes</code></pre></li>
</ol>
</li>
<li><p>使用docker运行redis</p>
<pre><code>docker run -p 6379:6379 --name redis \
-v /usr/java/docker/redis/redis.conf:/etc/redis/redis.conf \
-v /usr/java/docker/redis/data:/data \
-d redis:6.0 redis-server /etc/redis/redis.conf \
--appendonly yes</code></pre><p>命令解释说明：</p>
<blockquote>
<p>-p 6379:6379 端口映射：前表示主机部分，：后表示容器部分。</p>
<p>–name redis指定该容器名称，查看和进行操作都比较方便。</p>
<p>-v 挂载目录，规则与端口映射相同。</p>
<p>为什么需要挂载目录：个人认为docker是个沙箱隔离级别的容器，这个是它的特点及安全机制，不能随便访问外部（主机）资源目录，所以需要这个挂载目录机制。</p>
<p>-d redis:6.0 表示后台启动redis</p>
<p>redis-server /etc/redis/redis.conf  以配置文件启动redis，加载容器内的conf文件，最终找到的是挂载的目录/usr/local/docker/redis/redis.conf</p>
<p>–appendonly yes：redis启动后数据持久化</p>
</blockquote>
</li>
<li><p>查看是否运行成功</p>
<pre><code>docker ps | grep redis</code></pre></li>
<li><p>问题记录：</p>
<p>解决WARNING overcommit_memory is set to 0 Background save may fail under low memory condition：<a href="https://blog.csdn.net/ET1131429439/article/details/126660323" target="_blank" rel="noopener">https://blog.csdn.net/ET1131429439/article/details/126660323</a></p>
<p>redis客户端链接失败：<a href="https://blog.csdn.net/m0_67394006/article/details/126495657" target="_blank" rel="noopener">https://blog.csdn.net/m0_67394006/article/details/126495657</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用命令</title>
    <url>/2020/05/12/docker-chang-yong-ming-ling/</url>
    <content><![CDATA[<h1 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h1><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ol>
<li><p>搜索镜像</p>
<pre><code>docker search xxx</code></pre></li>
<li><p>下载镜像</p>
<pre><code>docker pull xxx</code></pre></li>
<li><p>查看镜像 </p>
<p>查看所有镜像</p>
<pre><code>docker images</code></pre><p> 查看指定镜像</p>
<pre><code>docker images | grep 容器名字</code></pre></li>
<li><p>删除镜像</p>
<pre><code>docker rmi  镜像name/镜像id(会提示先停止使用中的容器) </code></pre></li>
<li><p>查看所有容器</p>
<pre><code> docker ps -a</code></pre></li>
<li><p>查看容器运行日志</p>
<pre><code>docker logs 容器名称/容器id

#实时查看运行的日志
docker logs 容器名称/容器id -f</code></pre></li>
<li><p>停止容器运行</p>
<pre><code>docker stop 容器name/容器id</code></pre></li>
<li><p>终止容器后运行</p>
<pre><code>docker start 容器name/容器id</code></pre></li>
<li><p>容器重启</p>
<pre><code> docker restart 容器name/容器id</code></pre></li>
<li><p>删除容器</p>
<ol>
<li><p>删除没有运行的容器</p>
<pre><code>docker rm 容器name/容器id</code></pre></li>
<li><p>强制删除正在运行的容器</p>
<pre><code>docker rm -f 容器name/容器id</code></pre></li>
</ol>
</li>
<li><p>docker里面安装vim</p>
<pre><code>1. apt-get update
2. apt-get install vim</code></pre></li>
<li><p>docker修改容器开机自启</p>
<pre><code>docker update 容器id/名字 --restart=always</code></pre></li>
<li><p>进入容器内部</p>
<pre><code>docker exec -it 容器id/名字 bash</code></pre></li>
<li><p>挂载卷到外部修改</p>
<p>修改页面只需要去 主机的 /data/html</p>
<p>-v 这个给命令就是将外部的目录和容器内部的目录映射起来</p>
<pre><code>docker run --name=mynginx   \
-d  --restart=always \
-p  88:80 -v /data/html:/usr/share/nginx/html:ro  \
nginx</code></pre></li>
<li><p>复制文件</p>
<p>把容器指定位置的东西复制出来</p>
<pre><code> docker cp 5eff66eec7e1:/etc/nginx/nginx.conf  /data/conf/nginx.conf</code></pre><p>把外面的内容复制到容器里面</p>
<pre><code>docker cp  /data/conf/nginx.conf  5eff66eec7e1:/etc/nginx/nginx.conf</code></pre></li>
<li><p>限制容器内存</p>
<pre><code>docker run -m 512m --name=nginx 省略xxx</code></pre></li>
<li><p>查看容器占用内存、CPU等基本信息</p>
<pre><code>docker stats</code></pre></li>
</ol>
<h2 id="打包为新的镜像"><a href="#打包为新的镜像" class="headerlink" title="打包为新的镜像"></a>打包为新的镜像</h2><ol>
<li><p>提交改变：将修改后的容器打包成新的镜像，之后可以直接启动新的镜像。</p>
<pre><code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]

docker commit -a &quot;jiangfeng&quot;  -m &quot;首页变化&quot; 容器id/容器名字 mynginx:1.0
</code></pre></li>
<li><p>镜像传输</p>
<pre><code># 将自己创建的镜像保存成压缩包
docker save -o abc.tar mynginx:1.0

# 别的机器加载这个镜像
docker load -i abc.tar</code></pre></li>
</ol>
<h2 id="推送远程仓库"><a href="#推送远程仓库" class="headerlink" title="推送远程仓库"></a>推送远程仓库</h2><ol>
<li><p>基本命令</p>
<pre><code>docker tag local-image:tagname new-repo:tagname
docker push new-repo:tagname</code></pre></li>
<li><p>把旧镜像的名字，改成仓库要求的新版名字</p>
<pre><code>docker tag mynginx:1.0 1500041584/mynginx:1.0</code></pre></li>
<li><p>登录以及推出docker hub</p>
<pre><code>docker login </code></pre><pre><code>docker logout</code></pre></li>
<li><p>推动到docket hub 私人仓库</p>
<pre><code>docker push 1500041584/mynginx:1.0</code></pre></li>
<li><p>下载新的镜像</p>
<pre><code>docker pull 1500041584/mynginx:1.0</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令整理</title>
    <url>/2020/05/11/git-ming-ling-zheng-li/</url>
    <content><![CDATA[<h1 id="git命令整理"><a href="#git命令整理" class="headerlink" title="git命令整理"></a>git命令整理</h1><h2 id="拉取当前分支的远程代码"><a href="#拉取当前分支的远程代码" class="headerlink" title="拉取当前分支的远程代码"></a>拉取当前分支的远程代码</h2><p>git pull ：将当前分支远程上的更新拉取下来</p>
<h2 id="获取本地所有分支远程代码的更新"><a href="#获取本地所有分支远程代码的更新" class="headerlink" title="获取本地所有分支远程代码的更新"></a>获取本地所有分支远程代码的更新</h2><p>git fetch：将远程上的更新拉取下来。不包括当前分支的更新。（仅仅是远程分支的更新）</p>
<h2 id="修改本地指向远程仓库的地址"><a href="#修改本地指向远程仓库的地址" class="headerlink" title="修改本地指向远程仓库的地址"></a>修改本地指向远程仓库的地址</h2><ol>
<li><p>查看本地远程仓库地址</p>
<pre><code>git remote -v</code></pre></li>
</ol>
<ol start="2">
<li><p>修改仓库地址</p>
<pre><code>git remote set-url origin https://github.91chifun.workers.dev//https://github.com/JavaCodeShow/JavaCodeShow.github.io.git</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>java服务线上问题排查</title>
    <url>/2022/11/15/java-fu-wu-xian-shang-wen-ti-pai-cha/</url>
    <content><![CDATA[<h1 id="java服务线上问题排查"><a href="#java服务线上问题排查" class="headerlink" title="java服务线上问题排查"></a>java服务线上问题排查</h1><h2 id="1、内存"><a href="#1、内存" class="headerlink" title="1、内存"></a>1、内存</h2><h3 id="1-1、-查看服务占用内存"><a href="#1-1、-查看服务占用内存" class="headerlink" title="1.1、 查看服务占用内存"></a>1.1、 查看服务占用内存</h3><ol>
<li><p>可以通过prometheus查看，此处不做过多说明。</p>
</li>
<li><p>通过arthas的memory命令查看</p>
<pre><code>$ memory</code></pre><p>显示如下：</p>
<pre><code>Memory                           used      total      max        usage
heap                             32M       256M       4096M      0.79%
g1_eden_space                    11M       68M        -1         16.18%
g1_old_gen                       17M       184M       4096M      0.43%
g1_survivor_space                4M        4M         -1         100.00%
nonheap                          35M       39M        -1         89.55%
codeheap_&#39;non-nmethods&#39;          1M        2M         5M         20.53%
metaspace                        26M       27M        -1         96.88%
codeheap_&#39;profiled_nmethods&#39;     4M        4M         117M       3.57%
compressed_class_space           2M        3M         1024M      0.29%
codeheap_&#39;non-profiled_nmethods&#39; 685K      2496K      120032K    0.57%
mapped                           0K        0K         -          0.00%
direct                           48M       48M        -          100.00%
</code></pre></li>
<li><p>直接使用linux自带的命令查看</p>
<pre><code>top -o %MEM -b -n 1 | grep java | awk &#39;{print &quot;PID: &quot;$1&quot; \t 虚拟内存: &quot;$5 / 1024&quot;M \t 物理内存(实际占用内存): &quot;$6 / 1024&quot;M \t 共享内存: &quot;$7 / 1024&quot;M \t CPU使用率: &quot;$9&quot;% \t 内存使用率: &quot;$10&quot;%&quot;}&#39;</code></pre><p>显示如下：</p>
<pre><code>[root@iZuf6j6c7vo33inl2830e3Z spring-application-jar]# top -o %MEM -b -n 1 | grep java | awk &#39;{print &quot;PID: &quot;$1&quot; \t 虚拟内存: &quot;$5 / 1024&quot;M \t 物理内存: &quot;$6 / 1024&quot;M \t 共享内存: &quot;$7 / 1024&quot;M \t CPU使用率: &quot;$9&quot;% \t 内存使用率: &quot;$10&quot;%&quot;}&#39;
PID: 12959       虚拟内存: 2123.05M      物理内存: 329.488M      共享内存: 7.28125M      CPU使用率: 0.0%         内存使用率: 17.9%
PID: 10799       虚拟内存: 2110.75M      物理内存: 194.641M      共享内存: 13.418M       CPU使用率: 0.0%         内存使用率: 10.6%
PID: 28249       虚拟内存: 2508.25M      物理内存: 194.316M      共享内存: 6.32031M      CPU使用率: 0.0%         内存使用率: 10.6%
PID: 25613       虚拟内存: 2331.65M      物理内存: 169.684M      共享内存: 5.15625M      CPU使用率: 0.0%         内存使用率: 9.2%
[root@iZuf6j6c7vo33inl2830e3Z spring-application-jar]#     </code></pre></li>
</ol>
<h3 id="1-2、服务OOM如何排查"><a href="#1-2、服务OOM如何排查" class="headerlink" title="1.2、服务OOM如何排查"></a>1.2、服务OOM如何排查</h3><h4 id="1-2-1、获取dump文件"><a href="#1-2-1、获取dump文件" class="headerlink" title="1.2.1、获取dump文件"></a>1.2.1、获取dump文件</h4><ol>
<li><p>主动导出dump文件</p>
<ol>
<li><p>获取进程的PID</p>
<pre><code>ps -ef|grep java
jps -l</code></pre></li>
<li><p>根据pid，下载dump文件到当前路径，导出整个JVM 中内存信息</p>
<p>格式：jmap -dump:format=b,file=文件名 [pid]</p>
<pre><code>jmap -dump:format=b,file=/usr/java/dump/heapdump.hprof 32756</code></pre></li>
</ol>
</li>
</ol>
<h4 id="1-2-2、OOM时导出dump文件"><a href="#1-2-2、OOM时导出dump文件" class="headerlink" title="1.2.2、OOM时导出dump文件"></a>1.2.2、OOM时导出dump文件</h4><ol>
<li><p>我们可以添加 <strong>-XX:+HeapDumpOnOutOfMemoryError</strong> 参数开启“<strong>当堆内存空间溢出时输出堆的内存快照</strong>”功能，而 <strong>-XX:HeapDumpPath</strong> 参数则指定生成的堆转储存放位置，可以不填路径，只填文件名，说明是当前目录。</p>
<pre><code>#指定dump文件存放位置
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/java/dump/

#在当前服务的的根目录下面存放dump文件
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=testDump.hprof</code></pre></li>
</ol>
<h4 id="1-2-3、分析dump文件"><a href="#1-2-3、分析dump文件" class="headerlink" title="1.2.3、分析dump文件"></a>1.2.3、分析dump文件</h4><ol>
<li><p>如果是 <strong>Windows</strong> 系统我们也可以直接使用JDK自带的 <strong>jvisualvm</strong> 工具（在 <strong>JDK</strong> 的 <strong>bin</strong> 目录下：jvisualvm.exe）</p>
<p>目录位置：%JAVA_HOME%\bin,如果不确定JAVA_HOME的位置，可以在cmd命令行中输入：echo %JAVA_HOME%  确定位置</p>
<p><img src="https://img-blog.csdnimg.cn/53a7e17be93749cfa780ed8b1614ebab.png#pic_center" alt></p>
</li>
<li><p>从下面图片里面可以UserDTO这个对象占用了78.1%的内存，实例数是8720756个，而其他的对象占用内存并不大，那么罪魁祸首久事这个UserDTO对象，我们点击进去继续查看。</p>
<p><img src="https://img-blog.csdnimg.cn/0bdc2a2f34ad461bbc6f581f4899a92b.png#pic_center" alt></p>
<blockquote>
<p>如果出现内存不足，可以将%JAVA_HOME%\lib\visualvm\etc目录里面的visualvm.conf的堆内存修改一下。</p>
<pre><code>-Xms1024m -J-Xmx4096m</code></pre></blockquote>
</li>
<li><p>分析对象</p>
<p>从下面图片可以看到左边是这个UserDTO对象的所有实例，右上是对象的具体信息，包含对象里面的字段，右下是这个对象的被引用信息，在这个图里面也可以看到这个对象有8720756个，查看引用看到这个对象是在一个List里面，我们点击这个list继续往下看。</p>
<p><img src="https://img-blog.csdnimg.cn/9992d046bf414e4aa18ddbdb83a59c94.png#pic_center" alt></p>
</li>
<li><p>点开这个list会发现，这个list的大小是8720756万个，这个list的泛型是UserDTO对象，那么这个list中有8720756万个UsetDTO对象，那么OOM的原因也就水落石出了。从引用中可以看到这个list对象是在HelloService这个类里面，那么接下来结合代码不难发现是哪一处的代码出现问题，然后去改就ok了。</p>
<p><img src="https://img-blog.csdnimg.cn/7b86abe6a783434b82c233b9b9645df1.png#pic_center" alt></p>
</li>
</ol>
<h2 id="2、CPU"><a href="#2、CPU" class="headerlink" title="2、CPU"></a>2、CPU</h2><h3 id="2-1、查看系统CPU"><a href="#2-1、查看系统CPU" class="headerlink" title="2.1、查看系统CPU"></a>2.1、查看系统CPU</h3><p>linux服务器里面输入top命令，显示如下：</p>
<pre><code>  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND   
20571 root      20   0 2756184 296280  15236 S  80.4  7.8   0:36.48 java
  386 root      20   0   39108   5956   5628 S   6.2  0.2   0:33.12 systemd-journal 
11133 root      20   0  162104   2292   1616 R   6.2  0.1   0:00.14 top
    1 root      20   0   51916   3640   2156 S   0.0  0.1   0:51.89 systemd
    2 root      20   0       0      0      0 S   0.0  0.0   0:00.17 kthreadd
    4 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H         </code></pre><p>可以看到PID为20571的这个进程占用了80.4%的CPU。那么接下来就是分析这个java服务的cpu为什么这么高了。</p>
<h3 id="2-2、分析服务CPU过高"><a href="#2-2、分析服务CPU过高" class="headerlink" title="2.2、分析服务CPU过高"></a>2.2、分析服务CPU过高</h3><ol>
<li><p>安装arthas，选择PID对应的服务。</p>
</li>
<li><p>通过thread -n 3 就能找到消耗cpu最高的三个线程的执行情况。这里只贴出了消耗cpu最高的的线程。</p>
<pre><code>[arthas@3492]$ thread -n 3
thread -n 3
&quot;main&quot; Id=1 cpuUsage=89.35% deltaTime=187ms time=155281ms RUNNABLE
    at java.io.FileOutputStream.writeBytes(Native Method)
    at java.io.FileOutputStream.write(FileOutputStream.java:326)
    at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82)
    at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140)
    at java.io.PrintStream.write(PrintStream.java:482)
    at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)
    at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291)
    at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104)
    at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185)
    at java.io.PrintStream.write(PrintStream.java:527)
    at java.io.PrintStream.print(PrintStream.java:669)
    at java.io.PrintStream.println(PrintStream.java:806)
    at com.jf.HelloService.hello(HelloService.java:7)
</code></pre></li>
<li><p>从线程堆栈信息看到HelloService中hello方法导致的，代码位置是第7行。知道了代码的位置，接下来去分析就不难了。至此cpu的过高的原因也就水落石出了。 </p>
</li>
</ol>
]]></content>
      <categories>
        <category>线上问题排查</category>
      </categories>
      <tags>
        <tag>线上问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title>jmeter入门教程</title>
    <url>/2020/05/12/jmeter-ru-men-jiao-cheng/</url>
    <content><![CDATA[<h1 id="jmeter入门教程"><a href="#jmeter入门教程" class="headerlink" title="jmeter入门教程"></a>jmeter入门教程</h1><ol>
<li><p>下载jmeter</p>
<p>官网：<a href="https://jmeter.apache.org/" target="_blank" rel="noopener">https://jmeter.apache.org/</a></p>
</li>
<li><p>解压Jmeter包（解压后即可使用）</p>
</li>
<li><p>双击解压后的文件夹bin目录下的Jmeter.bat启动Jmeter</p>
<p><img src="https://img-blog.csdnimg.cn/6a719791901e437590603276a6cedfb7.png#pic_center" alt></p>
</li>
<li><p>创建线程组</p>
<p><img src="https://img-blog.csdnimg.cn/4380a774fbf3434c882fdb52761a6a4e.png#pic_center" alt></p>
</li>
</ol>
<ol start="5">
<li><p>设置线程参数：开启10个线程，同时启动，每个线程重复一次</p>
<p><img src="https://img-blog.csdnimg.cn/ed9ae8dac6a84651b340353c22a3e413.png#pic_center" alt></p>
</li>
<li><p>添加http请求</p>
<p><img src="https://img-blog.csdnimg.cn/a2f0e74ab3434f17b44fc1ebba739e13.png#pic_center" alt></p>
</li>
<li><p>发起get请求</p>
<p><img src="https://img-blog.csdnimg.cn/165e4d0459984b65872369baa1221a6f.png#pic_center" alt></p>
</li>
<li><p>发起post请求</p>
<p><img src="https://img-blog.csdnimg.cn/656f2ec789af4612861a48217a1a78d5.png#pic_center" alt></p>
</li>
</ol>
<p>注意：post请求需要设置content-type</p>
<p><img src="https://img-blog.csdnimg.cn/d3e49a6bd7e14893a5f38d438bb8ff48.png#pic_center" alt></p>
<p><img src="https://img-blog.csdnimg.cn/62028f9ed2f2439bb1c8d873a39a3d5f.png#pic_center" alt></p>
<ol start="9">
<li><p>查看请求结果</p>
<p><img src="https://img-blog.csdnimg.cn/694cb95c84e646d8b0888b27202fc59a.png#pic_center" alt></p>
</li>
<li><p>JMeter聚合报告（Aggregate Report）理解：<a href="https://blog.csdn.net/lion19930924/article/details/51189218" target="_blank" rel="noopener">https://blog.csdn.net/lion19930924/article/details/51189218</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>压测</category>
      </categories>
      <tags>
        <tag>jmeter</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka入门基本使用命令</title>
    <url>/2020/05/07/kafka-ru-men-shi-yong-guan-jian-ming-ling/</url>
    <content><![CDATA[<h2 id="一-修改配置文件"><a href="#一-修改配置文件" class="headerlink" title="一 修改配置文件"></a>一 修改配置文件</h2><p>在kafka解压目录下下有一个config的文件夹，里面放置的是我们的配置文件　　</p>
<ol>
<li>consumer.properites 消费者配置，此处我们使用默认的即可</li>
<li>producer.properties 生产者配置，此处我们使用默认的即可</li>
<li>server.properties kafka服务器的配置，此配置文件用来配置kafka服务器，</li>
<li>broker.id 申明当前kafka服务器在集群中的唯一ID，需配置为integer,并且集群中的每一个kafka服务器的id都应是唯一的，我们这里采用默认配置即可</li>
<li>listeners 申明此kafka服务器需要监听的端口号，如果是在本机上跑虚拟机运行可以不用配置本项，默认会使用localhost的地址。如果是在远程服务器上运行则必须配置，例如：listeners=PLAINTEXT:// 192.168.180.128:9092。并确保服务器的9092端口能够访问，如果想外部电脑上的程序也能访问此kafka，就必须指定ip地址，不然java中会报key为null的错误。zookeeper.connect 申明kafka所连接的zookeeper的地址 ，需配置为zookeeper的地址，由于本次使用的是kafka高版本中自带zookeeper，使用默认配置即可zookeeper.connect=localhost:2181</li>
</ol>
<pre class=" language-bash"><code class="language-bash">修改server.properties
本机使用：
        listeners<span class="token operator">=</span>PLAINTEXT://localhost:9092
        advertised.listeners<span class="token operator">=</span>PLAINTEXT://localhost:9092 
远程使用
         listeners<span class="token operator">=</span>PLAINTEXT://内网ip:9092
        advertised.listeners<span class="token operator">=</span>PLAINTEXT://公网ip:9092 </code></pre>
<h2 id="二-运行"><a href="#二-运行" class="headerlink" title="二 运行"></a>二 运行</h2><h3 id="2-1-启动zookeeper"><a href="#2-1-启动zookeeper" class="headerlink" title="2.1 启动zookeeper"></a>2.1 启动zookeeper</h3><p>cd进入kafka解压目录，输入</p>
<pre class=" language-bash"><code class="language-bash">bin/zookeeper-server-start.sh config/zookeeper.properties</code></pre>
<h3 id="2-2-启动kafka"><a href="#2-2-启动kafka" class="headerlink" title="2.2 启动kafka"></a>2.2 启动kafka</h3><p>cd进入kafka解压目录，输入</p>
<pre class=" language-bash"><code class="language-bash">bin/kafka-server-start.sh config/server.properties</code></pre>
<p><strong>kafka后台运行</strong></p>
<pre class=" language-bash"><code class="language-bash">bin/kafka-server-start.sh config/server.properties <span class="token operator">&amp;</span></code></pre>
<h3 id="2-3-创建topic"><a href="#2-3-创建topic" class="headerlink" title="2.3 创建topic"></a>2.3 创建topic</h3><p>创建一个名为test的topic　</p>
<pre class=" language-bash"><code class="language-bash">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic <span class="token function">test</span>　</code></pre>
<h3 id="2-4-查看topic"><a href="#2-4-查看topic" class="headerlink" title="2.4 查看topic"></a>2.4 查看topic</h3><pre><code>bin/kafka-topics.sh --list --zookeeper localhost:2181</code></pre><h3 id="2-5-创建消费者"><a href="#2-5-创建消费者" class="headerlink" title="2.5 创建消费者"></a>2.5 创建消费者</h3><p>可以创建一个用于消费topic为test的消费者，加上–from-beginning表示从开始所有的消息都显示出来</p>
<p>在kafka解压目录打开终端，输入</p>
<pre class=" language-bash"><code class="language-bash">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="token function">test</span> --from-beginning</code></pre>
<h3 id="2-6-创建一个消息生产者"><a href="#2-6-创建一个消息生产者" class="headerlink" title="2.6 创建一个消息生产者"></a>2.6 创建一个消息生产者</h3><p>在kafka解压目录打开一个新的终端，输入</p>
<pre class=" language-bash"><code class="language-bash">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic <span class="token function">test</span></code></pre>
<h3 id="2-7-删除topic"><a href="#2-7-删除topic" class="headerlink" title="2.7 删除topic"></a>2.7 删除topic</h3><pre class=" language-bash"><code class="language-bash">bin/kafka-topics.sh --delete --zookeeper localhost:2181 --topic accreditNotify</code></pre>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>linux安装RocketMQ</title>
    <url>/2021/03/31/linux-an-zhuang-rocketmq/</url>
    <content><![CDATA[<h1 id="linux安装RocketMQ"><a href="#linux安装RocketMQ" class="headerlink" title="linux安装RocketMQ"></a>linux安装RocketMQ</h1><p>前提条件：RocketMQ是基于java语言开发的。运行RocketMQ需要java环境。JDK的版本应该 &gt;= 1.8。请确保安装了JDK。</p>
<p>查看方式：</p>
<pre><code>[root@iZuf6j6c7vo33inl2830e3Z rocketmq]# java -version
java version &quot;1.8.0_131&quot;
Java(TM) SE Runtime Environment (build 1.8.0_131-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)</code></pre><p>本人用的是阿里云服务器。JDK版本是1.8，maven版本是3.6.3</p>
<h2 id="一、下载RocketMQ"><a href="#一、下载RocketMQ" class="headerlink" title="一、下载RocketMQ"></a>一、下载RocketMQ</h2><p>该地址列出了RocketMQ所有发布的版本：<a href="https://archive.apache.org/dist/rocketmq/" target="_blank" rel="noopener">https://archive.apache.org/dist/rocketmq/</a></p>
<p>这里将RocketMQ安装到Linux文件系统的/usr/java/rocketmq目录</p>
<pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/java/rocketmq</code></pre>
<p>下载之后进行解压缩：</p>
<pre class=" language-bash"><code class="language-bash">unzip rocketmq-all-4.8.0-bin-release.zip</code></pre>
<p>这边将目录名字修改一下,解压完毕也就不需要了，删除zip包</p>
<pre><code>rm -rf rocketmq-all-4.8.0-bin-release.zip
mv rocketmq-all-4.8.0-bin-release rocketmq</code></pre><p>解压目录说明</p>
<pre class=" language-bash"><code class="language-bash">rocketmq
    ├── benchmark <span class="token comment" spellcheck="true">#性能测试脚本</span>
    ├── bin       <span class="token comment" spellcheck="true">#命令行工具</span>
    ├── conf      <span class="token comment" spellcheck="true">#配置文件目录</span>
    ├── lib       <span class="token comment" spellcheck="true">#依赖的第三方类库</span>
    ├── LICENSE
    ├── NOTICE
    └── README.md</code></pre>
<h2 id="二、启动RocketMQ"><a href="#二、启动RocketMQ" class="headerlink" title="二、启动RocketMQ"></a>二、启动RocketMQ</h2><h3 id="2-1-启动NameServer"><a href="#2-1-启动NameServer" class="headerlink" title="2.1 启动NameServer"></a>2.1 启动NameServer</h3><ul>
<li><p>启动NameServer</p>
<pre><code>nohup sh bin/mqnamesrv &gt;/dev/null &amp;</code></pre></li>
<li><p>查看NameServer启动日志</p>
<pre><code>tail -500f ~/logs/rocketmqlogs/namesrv.log</code></pre></li>
</ul>
<h3 id="2-2-启动Broker"><a href="#2-2-启动Broker" class="headerlink" title="2.2 启动Broker"></a>2.2 启动Broker</h3><ul>
<li><p>启动broker</p>
<pre><code>nohup sh bin/mqbroker -n localhost:9876 &gt;/dev/null &amp;</code></pre></li>
<li><p>查看Broker启动日志</p>
<pre><code>tail -500f ~/logs/rocketmqlogs/broker.log </code></pre></li>
</ul>
<h3 id="2-3-启动失败内存问题解决"><a href="#2-3-启动失败内存问题解决" class="headerlink" title="2.3 启动失败内存问题解决"></a>2.3 启动失败内存问题解决</h3><ul>
<li><p>这里发现会由于内存不足启动失败</p>
<p>RocketMQ默认的虚拟机内存较大，启动NameServer和Broker如果因为内存不足失败，需要编辑如下两个配置文件，修改JVM内存大小</p>
<pre><code># 编辑runbroker.sh和runserver.sh修改默认JVM大小
vi runbroker.sh
vi runserver.sh</code></pre></li>
<li><p>参考设置：</p>
<pre><code>JAVA_OPT=&quot;${JAVA_OPT} -server -Xms128m -Xmx128m -Xmn64m -XX:MetaspaceSize=64m  -XX:MaxMetaspaceSize=128m&quot;</code></pre></li>
</ul>
<p>改完保存重新启动即可。查看启动日志验证是否成功。</p>
<p>也可以通过jps- l 来验证</p>
<pre><code>[root@iZuf6j6c7vo33inl2830e3Z rocketmq]# jps -l
20358 org.apache.rocketmq.broker.BrokerStartup
19965 org.apache.rocketmq.namesrv.NamesrvStartup
22349 sun.tools.jps.Jps</code></pre><h3 id="2-4-测试RocketMQ"><a href="#2-4-测试RocketMQ" class="headerlink" title="2.4 测试RocketMQ"></a>2.4 测试RocketMQ</h3><ul>
<li><p>发送消息：使用安装包的Demo发送消息</p>
<pre><code>sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</code></pre></li>
<li><p>接收消息</p>
<pre><code>sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</code></pre></li>
</ul>
<h3 id="2-5-关闭RocketMQ"><a href="#2-5-关闭RocketMQ" class="headerlink" title="2.5 关闭RocketMQ"></a>2.5 关闭RocketMQ</h3><ul>
<li><p>关闭NameServer</p>
<pre><code>sh bin/mqshutdown namesrv</code></pre></li>
<li><p>关闭Broker</p>
<pre><code>sh bin/mqshutdown broker</code></pre></li>
</ul>
<h2 id="三、RocketMQ集群搭建"><a href="#三、RocketMQ集群搭建" class="headerlink" title="三、RocketMQ集群搭建"></a>三、RocketMQ集群搭建</h2><p>一个完整的RocketMQ集群由NameServer集群，Broker集群，Producer集群，Consumer集群组成。本节主要介绍NameServer集群，Broker集群的搭建。</p>
<ul>
<li><p>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p>
</li>
<li><p>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。</p>
</li>
<li><p>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</p>
</li>
<li><p>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。</p>
</li>
</ul>
<h3 id="3-1-集群模式"><a href="#3-1-集群模式" class="headerlink" title="3.1 集群模式"></a>3.1 集群模式</h3><h4 id="1）单Master模式"><a href="#1）单Master模式" class="headerlink" title="1）单Master模式"></a>1）单Master模式</h4><p>这种方式风险较大，一旦Broker重启或者宕机时，会导致整个服务不可用。不建议线上环境使用,可以用于本地测试。</p>
<h4 id="2）多Master模式"><a href="#2）多Master模式" class="headerlink" title="2）多Master模式"></a>2）多Master模式</h4><p>一个集群无Slave，全是Master，例如2个Master或者3个Master，这种模式的优缺点如下：</p>
<ul>
<li>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</li>
<li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</li>
</ul>
<h4 id="3）多Master多Slave模式（异步）"><a href="#3）多Master多Slave模式（异步）" class="headerlink" title="3）多Master多Slave模式（异步）"></a>3）多Master多Slave模式（异步）</h4><p>每个Master配置一个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p>
<ul>
<li>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样；</li>
<li>缺点：Master宕机，磁盘损坏情况下会丢失少量消息。</li>
</ul>
<h4 id="4）多Master多Slave模式（同步）"><a href="#4）多Master多Slave模式（同步）" class="headerlink" title="4）多Master多Slave模式（同步）"></a>4）多Master多Slave模式（同步）</h4><p>每个Master配置一个Slave，有多对Master-Slave，HA采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：</p>
<ul>
<li>优点：数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；</li>
<li>缺点：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</li>
</ul>
<h3 id="3-2-环境变量配置"><a href="#3-2-环境变量配置" class="headerlink" title="3.2 环境变量配置"></a>3.2 环境变量配置</h3><pre><code>vim /etc/profile</code></pre><p>在profile文件的末尾加入如下命令</p>
<pre><code>#set rocketmq
ROCKETMQ_HOME=/usr/java/rocketmq
PATH=$PATH:$ROCKETMQ_HOME/bin
export ROCKETMQ_HOME PATH</code></pre><p>输入:wq! 保存并退出， 并使得配置立刻生效：</p>
<pre><code>source /etc/profile</code></pre><h3 id="3-3-防火墙配置"><a href="#3-3-防火墙配置" class="headerlink" title="3.3 防火墙配置"></a>3.3 防火墙配置</h3><p>宿主机需要远程访问虚拟机的rocketmq服务和web服务，需要开放相关的端口号，简单粗暴的方式是直接关闭防火墙</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 关闭防火墙</span>
systemctl stop firewalld.service 
<span class="token comment" spellcheck="true"># 查看防火墙的状态</span>
firewall-cmd --state 
<span class="token comment" spellcheck="true"># 禁止firewall开机启动</span>
systemctl disable firewalld.service</code></pre>
<p>或者为了安全，只开放特定的端口号，RocketMQ默认使用3个端口：9876 、10911 、11011 。如果防火墙没有关闭的话，那么防火墙就必须开放这些端口：</p>
<ul>
<li><code>nameserver</code> 默认使用 9876 端口</li>
<li><code>master</code> 默认使用 10911 端口</li>
<li><code>slave</code> 默认使用11011 端口</li>
</ul>
<p>执行以下命令：</p>
<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 开放name server默认端口</span>
firewall-cmd --remove-port<span class="token operator">=</span>9876/tcp --permanent
<span class="token comment" spellcheck="true"># 开放master默认端口</span>
firewall-cmd --remove-port<span class="token operator">=</span>10911/tcp --permanent
<span class="token comment" spellcheck="true"># 开放slave默认端口 (当前集群模式可不开启)</span>
firewall-cmd --remove-port<span class="token operator">=</span>11011/tcp --permanent 
<span class="token comment" spellcheck="true"># 重启防火墙</span>
firewall-cmd --reload</code></pre>
<h3 id="3-3-单Master模式"><a href="#3-3-单Master模式" class="headerlink" title="3.3 单Master模式"></a>3.3 单Master模式</h3><h4 id="3-3-1-创建消息存储路径"><a href="#3-3-1-创建消息存储路径" class="headerlink" title="3.3.1 创建消息存储路径"></a>3.3.1 创建消息存储路径</h4><p>系统根目录执行一下命令</p>
<pre><code>cd /
mkdir -p /data/rocketmq/single-master/broker-a/store
mkdir -p /data/rocketmq/single-master/broker-a/store/commitlog
mkdir -p /data/rocketmq/single-master/broker-a/store/consumequeue
mkdir -p /data/rocketmq/single-master/broker-a/store/index
mkdir -p /data/rocketmq/single-master/broker-a/store/checkpoint
mkdir -p /data/rocketmq/single-master/broker-a/store/abort</code></pre><h4 id="3-3-2-修改broker配置文件"><a href="#3-3-2-修改broker配置文件" class="headerlink" title="3.3.2  修改broker配置文件"></a>3.3.2  修改broker配置文件</h4><pre><code>vi /usr/java/rocketmq/conf/broker.conf</code></pre><pre><code>#所属集群名字
brokerClusterName=single-master
#broker名字，注意此处不同的配置文件填写的不一样
brokerName=broker-a
#0 表示 Master，&gt;0 表示 Slave
brokerId=0
#nameServer地址，分号分割
namesrvAddr=1.15.226.249:9876
# 你的公网IP
brokerIP1=1.15.226.249
#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数
defaultTopicQueueNums=4
#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭
autoCreateTopicEnable=true
#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭
autoCreateSubscriptionGroup=true
#Broker 对外服务的监听端口
listenPort=10911
#删除文件时间点，默认凌晨 4点
deleteWhen=04
#文件保留时间，默认 48 小时
fileReservedTime=48
#commitLog每个文件的大小默认1G
mapedFileSizeCommitLog=1073741824
#ConsumeQueue每个文件默认存30W条，根据业务情况调整
mapedFileSizeConsumeQueue=300000
#destroyMapedFileIntervalForcibly=120000
#redeleteHangedFileInterval=120000
#检测物理文件磁盘空间
diskMaxUsedSpaceRatio=88
#存储路径
storePathRootDir=/data/rocketmq/single-master/broker-a/store
#commitLog 存储路径
storePathCommitLog=/data/rocketmq/single-master/broker-a/store/commitlog
#消费队列存储路径存储路径
storePathConsumeQueue=/data/rocketmq/single-master/broker-a/store/consumequeue
#消息索引存储路径
storePathIndex=/data/rocketmq/single-master/broker-a/store/index
#checkpoint 文件存储路径
storeCheckpoint=/data/rocketmq/single-master/broker-a/store/checkpoint
#abort 文件存储路径
abortFile=/data/rocketmq/single-master/broker-a/store/abort
#限制的消息大小
maxMessageSize=65536
#flushCommitLogLeastPages=4
#flushConsumeQueueLeastPages=2
#flushCommitLogThoroughInterval=10000
#flushConsumeQueueThoroughInterval=60000
#Broker 的角色
#- ASYNC_MASTER 异步复制Master
#- SYNC_MASTER 同步双写Master
#- SLAVE
brokerRole=ASYNC_MASTER
#刷盘方式
#- ASYNC_FLUSH 异步刷盘
#- SYNC_FLUSH 同步刷盘
flushDiskType=ASYNC_FLUSH
#checkTransactionMessageEnable=false
#发消息线程池数量
sendMessageThreadPoolNums=18
#拉消息线程池数量
pullMessageThreadPoolNums=18</code></pre><h4 id="3-3-3-启动"><a href="#3-3-3-启动" class="headerlink" title="3.3.3 启动"></a>3.3.3 启动</h4><ul>
<li><p>启动NameServer</p>
<pre><code>nohup sh bin/mqnamesrv &gt;/dev/null &amp;</code></pre></li>
<li><p>查看NameServer启动日志</p>
<pre><code>tail -500f ~/logs/rocketmqlogs/namesrv.log</code></pre></li>
<li><p>启动broker</p>
<pre><code>nohup sh bin/mqbroker -c conf/broker.conf &gt;/dev/null &amp;</code></pre></li>
<li><p>查看Broker启动日志</p>
<pre><code>tail -500f ~/logs/rocketmqlogs/broker.log </code></pre></li>
<li><p>关闭NameServer</p>
<pre><code>sh bin/mqshutdown namesrv</code></pre></li>
<li><p>关闭Broker</p>
<pre><code>sh bin/mqshutdown broker</code></pre></li>
</ul>
<p>注意：broker启动时不会读取broker.conf中的配置，尽管也可以启动，但是如果需要使得配置文件生效，必须通过-c参数进行指定。</p>
<p>验证启动成功</p>
<pre><code>[root@iZuf6j6c7vo33inl2830e3Z spring-application-jar]# jps -l
1354 org.apache.rocketmq.namesrv.NamesrvStartup
1739 org.apache.rocketmq.broker.BrokerStartup
[root@iZuf6j6c7vo33inl2830e3Z spring-application-jar]# </code></pre><h4 id="3-3-4-查看集群列表信息（集群中使用）"><a href="#3-3-4-查看集群列表信息（集群中使用）" class="headerlink" title="3.3.4 查看集群列表信息（集群中使用）"></a>3.3.4 查看集群列表信息（集群中使用）</h4><pre class=" language-bash"><code class="language-bash">$ sh bin/mqadmin clusterList -n 1.15.226.249:9876
<span class="token comment" spellcheck="true">#Cluster Name    #Broker Name   #BID        #Addr           #Version   #...(略)</span>
single-master    broker-a      0        192.168.1.3:10911     V4_6_0    …</code></pre>
<p>输出的每一列说明如下：</p>
<ul>
<li>Cluster Name：集群的名称，即brokerClusterName配置项的值</li>
<li>Broker Name：Broker的名称，即brokerName配置项的值</li>
<li>BID：Broker的ID，这里显示为0，即brokerId配置项的值</li>
<li>Addr：监听的IP/端口，供生产者/消费者访问，端口即listenPort配置项的值</li>
<li>Version：broker的版本</li>
</ul>
<h2 id="四、RocketMQ控制台安装"><a href="#四、RocketMQ控制台安装" class="headerlink" title="四、RocketMQ控制台安装"></a>四、RocketMQ控制台安装</h2><p>下载代码并编译打包</p>
<pre><code>git clone https://github.com/apache/rocketmq-externals
cd rocketmq-console
mvn clean package -Dmaven.test.skip=true</code></pre><p>注意：打包前在<code>rocketmq-console</code>中配置<code>namesrv</code>集群地址：</p>
<pre class=" language-sh"><code class="language-sh">rocketmq.config.namesrvAddr=1.15.226.249:9876</code></pre>
<p>最好将server.port也修改一下。默认是8080。</p>
<p>上传到linux服务器任意一个目录。</p>
<p>启动rocketmq-console：注意jar包的名称需要改为自己的jar包名称</p>
<pre class=" language-sh"><code class="language-sh">nohup java -jar -XX:MetaspaceSize=64m -XX:MaxMetaspaceSize=128m -Xms128m -Xmx128m -Xmn32m rocketmq-console-ng-1.0.0.jar >/dev/null &</code></pre>
<p>启动成功后，我们就可以通过浏览器访问：http://公网ip:port</p>
<h2 id="五、遇到的问题"><a href="#五、遇到的问题" class="headerlink" title="五、遇到的问题"></a>五、遇到的问题</h2><ol>
<li><p>启动broker失败</p>
<pre><code>2020-8-24 13:11:11 INFO main - Try to shutdown service thread:AllocateMappedFileService started:true lastThread:Thread[AllocateMappedFileService,5,main]
2020-8-24 13:11:11 INFO main - shutdown thread AllocateMappedFileService interrupt true
2020-8-24 13:11:11 INFO main - join thread AllocateMappedFileService elapsed time(ms) 5 90000
2020-8-24 13:11:11 INFO main - Try to shutdown service thread:PullRequestHoldService started:false lastThread:null</code></pre><p>解决原因：将broker的存储路径storePathRootDir给注释掉。使用broker默认的存储路径（/root/store）。</p>
<p>可以临时解决一下。这不是很好的解决方案。具体原因未找出来。</p>
</li>
<li><p>producer没有连接上broker</p>
<pre><code>com.alibaba.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;127.0.0.1:9876&gt; failed</code></pre><p>这个修改broker的配置文件。需要修改两个参数</p>
<pre><code># 你的公网IP
namesrvAddr=1.15.226.249:9876
# 你的公网IP，不指定就是127.0.0.1。而127.0.0.1在外网环境中无法访问。
brokerIP1=1.15.226.249</code></pre><p>rocketmq控制台也是如此。需要指定namesrvAddr的外网ip。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>linux安装jenkins部署SpringBoot应用</title>
    <url>/2021/03/30/linux-an-zhuang-jenkins/</url>
    <content><![CDATA[<h1 id="linux安装jenkins部署SpringBoot应用"><a href="#linux安装jenkins部署SpringBoot应用" class="headerlink" title="linux安装jenkins部署SpringBoot应用"></a>linux安装jenkins部署SpringBoot应用</h1><h2 id="一、安装jdk和maven"><a href="#一、安装jdk和maven" class="headerlink" title="一、安装jdk和maven"></a>一、安装jdk和maven</h2><p>首先在安装jenkins之前。需要先安装jdk 和 maven。至于 jdk 和 maven 和安装教程，这里就不说了。</p>
<p><strong>查看jdk安装成功</strong>：java -version</p>
<p>显示下面的信息说明安装成功</p>
<pre><code>[root@iZuf6j6c7vo33inl2830e3Z ~]# java -version
java version &quot;1.8.0_131&quot;
Java(TM) SE Runtime Environment (build 1.8.0_131-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)
[root@iZuf6j6c7vo33inl2830e3Z ~]# </code></pre><p><strong>查看maven安装成功</strong>：mvn -v</p>
<p>显示下面的信息说明安装成功</p>
<pre><code>[root@iZuf6j6c7vo33inl2830e3Z ~]# mvn -v
Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)
Maven home: /usr/java/apache-maven-3.6.3
Java version: 1.8.0_131, vendor: Oracle Corporation, runtime: /usr/java/jdk1.8/jre
Default locale: en_US, platform encoding: UTF-8
OS name: &quot;linux&quot;, version: &quot;3.10.0-1160.11.1.el7.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;
[root@iZuf6j6c7vo33inl2830e3Z ~]# </code></pre><p>在进行下面的操作之前，请确保这两个安装完毕。</p>
<h2 id="二、安装git"><a href="#二、安装git" class="headerlink" title="二、安装git"></a>二、安装git</h2><h3 id="2-1-安装git命令"><a href="#2-1-安装git命令" class="headerlink" title="2.1 安装git命令"></a>2.1 安装git命令</h3><pre><code>yum install git
</code></pre><h3 id="2-2-查看git是否安装成功"><a href="#2-2-查看git是否安装成功" class="headerlink" title="2.2 查看git是否安装成功"></a>2.2 查看git是否安装成功</h3><pre><code>[root@iZuf6j6c7vo33inl2830e3Z ~]# git version
git version 1.8.3.1</code></pre><h3 id="2-3-配置全局的用户名和密码"><a href="#2-3-配置全局的用户名和密码" class="headerlink" title="2.3 配置全局的用户名和密码"></a>2.3 配置全局的用户名和密码</h3><pre><code>git config --global user.name &quot;admin&quot;
git config --global user.email &quot;admin@abc.com&quot;</code></pre><h3 id="2-4-生成授权证书"><a href="#2-4-生成授权证书" class="headerlink" title="2.4 生成授权证书"></a>2.4 生成授权证书</h3><p>中间直接全部回车就行</p>
<pre><code>ssh-keygen -t rsa -C &quot;admin@abc.com&quot;</code></pre><h3 id="2-5-github-ssh配置"><a href="#2-5-github-ssh配置" class="headerlink" title="2.5 github ssh配置"></a>2.5 github ssh配置</h3><p>复制/root/.ssh/id_rsa.pub里的内容，到github进行配置ssh公钥</p>
<h2 id="三、在linux服务器里面安装jenkins"><a href="#三、在linux服务器里面安装jenkins" class="headerlink" title="三、在linux服务器里面安装jenkins"></a>三、在linux服务器里面安装jenkins</h2><h3 id="3-1-下载jenkins的rpm包"><a href="#3-1-下载jenkins的rpm包" class="headerlink" title="3.1 下载jenkins的rpm包"></a>3.1 下载jenkins的rpm包</h3><p>这是目前最新 jenkins LTS版本，在<a href="https://mirrors.tuna.tsinghua.edu.cnredhat-stable/" target="_blank" rel="noopener">清华大学镜像站</a>  这个里面下载最新版的jenkins。</p>
<p>mkdir /usr/java/jenkins</p>
<p>然后上传到linux服务器。</p>
<pre><code>[root@iZuf6j6c7vo33inl2830e3Z jenkins]# pwd
/usr/java/jenkins
[root@iZuf6j6c7vo33inl2830e3Z jenkins]# ls
jenkins-2.222.3-1.1.noarch.rpm
[root@iZuf6j6c7vo33inl2830e3Z jenkins]# </code></pre><h3 id="3-2-安装"><a href="#3-2-安装" class="headerlink" title="3.2 安装"></a>3.2 安装</h3><pre><code>sudo yum install jenkins-2.222.3-1.1.noarch.rpm</code></pre><h3 id="3-3-修改端口"><a href="#3-3-修改端口" class="headerlink" title="3.3 修改端口"></a>3.3 修改端口</h3><p>jenkins 默认8080端口，建议修改一下。以免和tomcat的默认端口号冲突。</p>
<pre><code>vim /etc/sysconfig/jenkins</code></pre><p>可以看到  JENKINS_PORT=”8080”， 这里改为   JENKINS_PORT=”8091”</p>
<h3 id="3-4-修改默认镜像源"><a href="#3-4-修改默认镜像源" class="headerlink" title="3.4 修改默认镜像源"></a>3.4 修改默认镜像源</h3><pre><code>vim /var/libhudson.model.UpdateCenter.xml </code></pre><p>将 url 修改为 清华大学官方镜像：<a href="https://mirrors.tuna.tsinghua.edu.cnupdates/update-center.json" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cnupdates/update-center.json</a></p>
<pre><code>&lt;?xml version=&#39;1.1&#39; encoding=&#39;UTF-8&#39;?&gt;
&lt;sites&gt;
  &lt;site&gt;
    &lt;id&gt;default&lt;/id&gt;
    &lt;url&gt;https://mirrors.tuna.tsinghua.edu.cnupdates/update-center.json&lt;/url&gt;
  &lt;/site&gt;
&lt;/sites&gt;</code></pre><h3 id="3-5-启动jenkins"><a href="#3-5-启动jenkins" class="headerlink" title="3.5 启动jenkins"></a>3.5 启动jenkins</h3><pre><code>启动jenkins：service jenkins start
关闭jenkins：service jenkins stop
重启jenkins：service jenkins restart
</code></pre><p>这里因为没有修改jdk的地址，会启动失败</p>
<pre><code>[root@iZuf6j6c7vo33inl2830e3Z jenkins]# systemctl start jenkins.service
Job for jenkins.service failed because the control process exited with error code. See &quot;systemctl status jenkins.service&quot; and &quot;journalctl -xe&quot; for details.
[root@iZuf6j6c7vo33inl2830e3Z jenkins]# </code></pre><p>查看失败原因</p>
<pre><code>systemctl status jenkins.service</code></pre><pre><code>
[root@iZuf6j6c7vo33inl2830e3Z jenkins]# systemctl status jenkins.service
● jenkins.service - LSB: Jenkins Automation Server
   Loaded: loaded (/etc/rc.d/init.d/jenkins; bad; vendor preset: disabled)
   Active: failed (Result: exit-code) since Mon 2021-03-29 15:07:28 CST; 19s ago
     Docs: man:systemd-sysv-generator(8)
  Process: 18344 ExecStart=/etc/rc.d/init.d/jenkins start (code=exited, status=1/FAILURE)

Mar 29 15:07:28 iZuf6j6c7vo33inl2830e3Z systemd[1]: Starting LSB: Jenkins Automation Server...
Mar 29 15:07:28 iZuf6j6c7vo33inl2830e3Z runuser[18351]: pam_unix(runuser:session): session opened for user jenkins by (uid=0)
Mar 29 15:07:28 iZuf6j6c7vo33inl2830e3Z jenkins[18344]: Starting Jenkins bash: /usr/bin/java: No such file or directory
Mar 29 15:07:28 iZuf6j6c7vo33inl2830e3Z systemd[1]: jenkins.service: control process exited, code=exited status=1
Mar 29 15:07:28 iZuf6j6c7vo33inl2830e3Z jenkins[18344]: [FAILED]
Mar 29 15:07:28 iZuf6j6c7vo33inl2830e3Z systemd[1]: Failed to start LSB: Jenkins Automation Server.
Mar 29 15:07:28 iZuf6j6c7vo33inl2830e3Z systemd[1]: Unit jenkins.service entered failed state.
Mar 29 15:07:28 iZuf6j6c7vo33inl2830e3Z systemd[1]: jenkins.service failed.
</code></pre><p>从这一行：Mar 29 15:07:28 iZuf6j6c7vo33inl2830e3Z jenkins[18344]: Starting Jenkins bash: /usr/bin/java: No such file or directory</p>
<p>可以看到是没有修改jdk的地址导致的。 </p>
<p>如果忘了jdk的地址可以通过    which java  这个命令查看</p>
<p>修改jenkins里面jdk的地址：</p>
<pre><code>vim /etc/init.d/jenkins</code></pre><p>在这个文件里面找到修改jdk地址的地方，改为自己的jdk地址就好了。然后重新启动</p>
<h3 id="3-6-查看jenkins启动成功"><a href="#3-6-查看jenkins启动成功" class="headerlink" title="3.6 查看jenkins启动成功"></a>3.6 查看jenkins启动成功</h3><pre><code>ps -ef | grep jenkins</code></pre><h3 id="3-7-访问jenkins"><a href="#3-7-访问jenkins" class="headerlink" title="3.7 访问jenkins"></a>3.7 访问jenkins</h3><p>http://公网ip地址:端口号</p>
<p>我本人的是：<a href="http://139.224.103.236:8091" target="_blank" rel="noopener">http://139.224.103.236:8091</a></p>
<h2 id="三、jenkins初始化配置"><a href="#三、jenkins初始化配置" class="headerlink" title="三、jenkins初始化配置"></a>三、jenkins初始化配置</h2><p><img src="/2021/03/30/linux-an-zhuang-jenkins/Snipaste_2021-03-29_21-49-44.png" alt="Snipaste_2021-03-29_21-49-44"></p>
<p>输入下面的命令，即可获取密码</p>
<pre class=" language-undefined"><code class="language-undefined">cat /root/.jenkins/secrets/initialAdminPassword  </code></pre>
<p>安装插件，直接安装默认提供的插件即可。</p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/6907580-d2ae24d404f8d137.png" alt></p>
<p>创建管理员账号</p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/6907580-ce4cf9c7eb5b435f.png" alt="6907580-ce4cf9c7eb5b435f"></p>
<h2 id="四、jenkins基本配置"><a href="#四、jenkins基本配置" class="headerlink" title="四、jenkins基本配置"></a>四、jenkins基本配置</h2><blockquote>
<p>开发人员将工作区的代码提交到代码库（svn或者git），代码库再调用钩子程序通知Jenkins（我已经更新了代码，你也要重新部署一版了），钩子程序是我们自己编写，这个钩子程序很容易后续会提到怎么编写钩子程序<br>Jenkins收到代码库的提醒之后立马去代码库里获取最新的源码，再通过调用maven插件将源码打包成jar，再通过Publish over SSH插件将jar包传到一台或者多台服务器上，再调用服务器的脚本启动jar包，这就是Jenkins工作的整体流程。</p>
</blockquote>
<h3 id="4-1-插件安装"><a href="#4-1-插件安装" class="headerlink" title="4.1 插件安装"></a>4.1 插件安装</h3><p><strong>安装Publish over SSH插件并配置</strong></p>
<p>系统管理==》插件管理</p>
<p>搜索Publish over SSH下载安装成功后后重新登陆jenkins</p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/Snipaste_2021-03-30_14-06-03.png" alt></p>
<p>​        </p>
<h3 id="4-2-系统配置"><a href="#4-2-系统配置" class="headerlink" title="4.2 系统配置"></a>4.2 系统配置</h3><p><strong>系统配置里面有一些实用的功能可以进行配置。需要的话可以自行配置。</strong></p>
<p>拉到最后面找到Publish over SSH，点击新增</p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/20200524113201698.png" alt></p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/20200524113301937.png" alt></p>
<p>​    name：随便填<br>​    Hostname：服务器IP（这个就是要把打包好的jar包发送并运行的目标主机）<br>​    Username：root<br>​    Remote Directory：要发送到的远程主机的目录，这里我们填 / 根目录就行，因为后面这个路径我们还要配置</p>
<p>​    填好之后在点击高级配置密码和端口</p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/Snipaste_2021-03-29_23-38-06.png" alt></p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/Snipaste_2021-03-29_23-39-26.png" alt></p>
<p>​    测试一下，能连接上即可。</p>
<h3 id="4-3-全局工具配置"><a href="#4-3-全局工具配置" class="headerlink" title="4.3 全局工具配置"></a>4.3 全局工具配置</h3><p>在这里配置jdk，git，maven的位置</p>
<p><strong>maven配置</strong></p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/Snipaste_2021-03-29_22-03-22.png" alt></p>
<p>​        <strong>JDK安装</strong></p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/Snipaste_2021-03-29_22-04-56.png" alt></p>
<p>​    <strong>git安装</strong></p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/Snipaste_2021-03-29_22-05-59.png" alt></p>
<p>​    <strong>maven安装</strong></p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/Snipaste_2021-03-29_22-06-54.png" alt></p>
<h3 id="4-4-节点配置"><a href="#4-4-节点配置" class="headerlink" title="4.4 节点配置"></a>4.4 节点配置</h3><p>在Jenkins中依次点击：系统管理 -&gt; 节点管理 -&gt; 新建节点</p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/20191019135659465.png" alt></p>
<p>保存后，点击启动代理配置，查看日志是否成功</p>
<h2 id="五、构建maven项目"><a href="#五、构建maven项目" class="headerlink" title="五、构建maven项目"></a>五、构建maven项目</h2><p>接下来可以新建一个任务执行了</p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/Snipaste_2021-03-30_14-09-30.png" alt></p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/Snipaste_2021-03-30_14-11-34.png" alt></p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/Snipaste_2021-03-30_14-13-18.png" alt></p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/Snipaste_2021-03-30_14-17-03.png" alt></p>
<p>配置项目构建完成后进行的操作。这里可以配置通过ssh连接远程其他服务器执行，或者本机直接执行等。</p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/Snipaste_2021-03-30_15-43-54.png" alt></p>
<p>本机运行shell命令</p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/Snipaste_2021-03-30_14-19-12.png" alt></p>
<p>远程服务器上运行shell命令。这个服务器就是在前面通过publish and ssh配置的服务器。</p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/Snipaste_2021-03-30_00-03-14.png" alt></p>
<p>术语解释：</p>
<blockquote>
<p><strong>Source files</strong>：Source files的目录是基于当前项目的目录(可以从jenkins的安装目录下找到)：例如当前项目名称为distribute-id-ms，则对于root用户，Source files中的目录是相对于/usr/lib/jenkins/workspace/distribute-id-ms目录下的，因此，如果我们要发送distribute-id-ms下的target目录下的distribute-id-ms-1.0.jar包，所以这里需要填写：target/distribute-id-ms-1.0.jar</p>
<p><strong>Remove prefix</strong>：表示需要移除的目录，比如这里填写target，则表示发布时，只把distribute-id-ms-1.0.jar发布到远程linux，而不包含target目录结构</p>
<p><strong>Remote directory</strong>：表示需要把编译好的war包发布到远程linux的哪个目录下</p>
<p><strong>Exec command</strong>：需要执行的shell命令，shell命令在远程linux服务器上执行.</p>
</blockquote>
<p>shell脚本配置如下：</p>
<pre><code>#!/bin/sh

echo &quot;开始执行shell脚本&quot;

# 在jenkins环境中一定要加这句话，否则这个脚本进程最后会被杀死
export BUILD_ID=dontKillMe

# 指定最后编译好的jar的存放位置
JAR_PATH=/usr/java/spring-application-jar

# 如果路径不存在，就创建路径
[ ! -e $JAR_PATH ] &amp;&amp; mkdir -p $JAR_PATH 

# 指定jenkins中存放编译好的jar的位置
JENKINS_JAR_PATH=/usr/lib/jenkins/workspace/distribute-id-ms/target

# 如果路径不存在，就创建路径
[ ! -e $JENKINS_JAR_PATH ] &amp;&amp; mkdir -p $JENKINS_JAR_PATH

# 指定jenkins中存放编译好的jar的名称(这个jar的名字和pom文件配置有关)
JENKINS_JAR_NAME=distribute-id-ms-1.0.jar

# 获取该项目的进程号，用于重新部署项目前杀死进程
pid=`ps -ef|grep distribute-id-ms-1.0.jar | grep -v grep|awk &#39;{print $2}&#39;`

echo &quot;  =====关闭Java应用======&quot;

for i in $pid
do
  echo &quot;Kill the $1 process [ $i ]&quot;
  kill -9 $i
done

echo &quot;  =====启动Java应用======&quot;

# 进入Jenkins中编译好的jar的位置
cd ${JENKINS_JAR_PATH}

# 将Jenkins中编译好的jar复制到最终存放项目jar的位置
cp $JENKINS_JAR_PATH/$JENKINS_JAR_NAME $JAR_PATH

# 进入到存放项目jar的位置
cd ${JAR_PATH}

# 后台启动项目，并且将控制台日志输出到nohup.out中

nohup java -jar ${JENKINS_JAR_NAME} &gt;/dev/null &amp;

echo &quot;shell脚本执行完毕&quot;

</code></pre><p><strong>注意事项：上面的目录是我自身配置的目录。实际目录根据自身情况检查一下。以免出现不必要的错误。这个可以在服务器上面创建一个脚本执行检查一下。</strong></p>
<p>最后，保存一下。构建项目即可。根据构建日志分析项目构建情况。</p>
<p><img src="/2021/03/30/linux-an-zhuang-jenkins/Snipaste_2021-03-30_16-28-53.png" alt></p>
<p>至此：使用Jenkins运行SpringBoot项目到此结束。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>通过实际部署Jenkins，并构建SpringBoot + maven项目，大大加深了对jenkins的熟悉。看到最后的build success</p>
<p>，内心还是有点小激动的。实际部署操作一遍，并且写这篇博客共花了两天的时间。期间，也参考了其他人的博客，非常感谢！</p>
<p>写这边博客的初衷，也是网上很难找到一篇从头到尾完整的使用Jenkins构建maven项目发布的教程。</p>
<p>希望这边博客，能对各位有所帮助！！！</p>
]]></content>
      <categories>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令</title>
    <url>/2021/03/26/linux-chang-yong-ming-ling/</url>
    <content><![CDATA[<h3 id><a href="#" class="headerlink" title></a></h3><h2 id="一、查看文本"><a href="#一、查看文本" class="headerlink" title="一、查看文本"></a>一、查看文本</h2><h2 id="二、搜索文本里面的内容"><a href="#二、搜索文本里面的内容" class="headerlink" title="二、搜索文本里面的内容"></a>二、搜索文本里面的内容</h2><h2 id="三、端口号"><a href="#三、端口号" class="headerlink" title="三、端口号"></a>三、端口号</h2><ol>
<li><h3 id="查看端口号是否在使用："><a href="#查看端口号是否在使用：" class="headerlink" title="查看端口号是否在使用："></a>查看端口号是否在使用：</h3><p>lsof -i:8080</p>
</li>
</ol>
<ol start="2">
<li><h3 id="对外部开放端口号"><a href="#对外部开放端口号" class="headerlink" title="对外部开放端口号"></a>对外部开放端口号</h3><p><strong>查询指定端口是否已经开放</strong><br>firewall-cmd –query-port=3306/tcp<br>返回yes/no。此时也有可能返回firewalld is not running，此时需要打开防火墙在开放端口。</p>
</li>
</ol>
<p>   <strong>添加指定需要开放的端口：</strong><br>   firewall-cmd –add-port=3306/tcp –permanent</p>
<p>   <strong>载入添加的端口：</strong><br>   firewall-cmd –reload</p>
<h2 id="四、防火墙"><a href="#四、防火墙" class="headerlink" title="四、防火墙"></a>四、防火墙</h2><ol>
<li><p>查看防火墙状态 systemctl status firewalld</p>
</li>
<li><p>开启防火墙 systemctl start firewalld</p>
</li>
<li><p>关闭防火墙 systemctl stop firewalld</p>
</li>
</ol>
<h2 id="五、内存"><a href="#五、内存" class="headerlink" title="五、内存"></a>五、内存</h2><p>​    free -h</p>
<h2 id="六、磁盘"><a href="#六、磁盘" class="headerlink" title="六、磁盘"></a>六、磁盘</h2><p>​     df -h</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>java应用服务器内存处理</title>
    <url>/2022/06/10/linux-fu-wu-qi-java-nei-cun-chu-li/</url>
    <content><![CDATA[<h1 id="java服务器内存处理"><a href="#java服务器内存处理" class="headerlink" title="java服务器内存处理"></a>java服务器内存处理</h1><h2 id="查看服务器总内存占用"><a href="#查看服务器总内存占用" class="headerlink" title="查看服务器总内存占用"></a>查看服务器总内存占用</h2><pre><code>free -h</code></pre><p>显示如下：</p>
<pre><code>[root@iZuf6j6c7vo33inl2830e3Z spring-application-jar]# free -h
              total        used        free      shared  buff/cache   available
Mem:           1.8G        1.4G        170M        3.7M        259M        284M
Swap:            0B          0B          0B
[root@iZuf6j6c7vo33inl2830e3Z spring-application-jar]# 
</code></pre><h2 id="清除操作系统缓存"><a href="#清除操作系统缓存" class="headerlink" title="清除操作系统缓存"></a>清除操作系统缓存</h2><pre><code>echo 3 &gt; /proc/sys/vm/drop_caches</code></pre><h2 id="查看java内存占用"><a href="#查看java内存占用" class="headerlink" title="查看java内存占用"></a>查看java内存占用</h2><pre><code>top -o %MEM -b -n 1 | grep java | awk &#39;{print &quot;PID: &quot;$1&quot; \t 虚拟内存: &quot;$5 / 1024&quot;M \t 物理内存(实际占用内存): &quot;$6 / 1024&quot;M \t 共享内存: &quot;$7 / 1024&quot;M \t CPU使用率: &quot;$9&quot;% \t 内存使用率: &quot;$10&quot;%&quot;}&#39;</code></pre><p>显示如下：</p>
<pre><code>[root@iZuf6j6c7vo33inl2830e3Z spring-application-jar]# top -o %MEM -b -n 1 | grep java | awk &#39;{print &quot;PID: &quot;$1&quot; \t 虚拟内存: &quot;$5 / 1024&quot;M \t 物理内存: &quot;$6 / 1024&quot;M \t 共享内存: &quot;$7 / 1024&quot;M \t CPU使用率: &quot;$9&quot;% \t 内存使用率: &quot;$10&quot;%&quot;}&#39;
PID: 12959       虚拟内存: 2123.05M      物理内存: 329.488M      共享内存: 7.28125M      CPU使用率: 0.0%         内存使用率: 17.9%
PID: 10799       虚拟内存: 2110.75M      物理内存: 194.641M      共享内存: 13.418M       CPU使用率: 0.0%         内存使用率: 10.6%
PID: 28249       虚拟内存: 2508.25M      物理内存: 194.316M      共享内存: 6.32031M      CPU使用率: 0.0%         内存使用率: 10.6%
PID: 25613       虚拟内存: 2331.65M      物理内存: 169.684M      共享内存: 5.15625M      CPU使用率: 0.0%         内存使用率: 9.2%
[root@iZuf6j6c7vo33inl2830e3Z spring-application-jar]# </code></pre><h2 id="查看PID所在目录"><a href="#查看PID所在目录" class="headerlink" title="查看PID所在目录"></a>查看PID所在目录</h2><pre><code>lsof -p PID
# 示例如下
# cwd: 表示 current work dirctory, 即：应用程序的当前工作目录
lsof -p PID | grep cwd</code></pre><h2 id="指定JVM内存运行java包"><a href="#指定JVM内存运行java包" class="headerlink" title="指定JVM内存运行java包"></a>指定JVM内存运行java包</h2><pre><code>nohup java -jar -XX:MetaspaceSize=64m -XX:MaxMetaspaceSize=128m -Xms128m -Xmx128m -Xmn64m  -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/java/dump/ microservicecloud-eureka-server-7001-1.0-SNAPSHOT.jar  &gt;/dev/null &amp;</code></pre><blockquote>
<p> Xms : 堆内存初始大小</p>
<p> Xmx : 堆内存最大值</p>
<p> Xmn：年轻代大小</p>
<p> MetaspaceSize: 元空间大小</p>
<p> MaxMetaspaceSize ：最大元空间大小</p>
</blockquote>
<h2 id="OOM时保存dump文件"><a href="#OOM时保存dump文件" class="headerlink" title="OOM时保存dump文件"></a>OOM时保存dump文件</h2><pre><code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/java/dump/</code></pre>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>prometheus告警规则配置</title>
    <url>/2020/07/01/prometheus-gao-jing-gui-ze-pei-zhi/</url>
    <content><![CDATA[<h2 id="1-创建告警规则配置文件"><a href="#1-创建告警规则配置文件" class="headerlink" title="1. 创建告警规则配置文件"></a>1. 创建告警规则配置文件</h2><p>创建告警规则配置文件first_rules.yml，建议放在与prometheus.yml同级目录</p>
<h2 id="2-修改prometheus配置文件"><a href="#2-修改prometheus配置文件" class="headerlink" title="2. 修改prometheus配置文件"></a>2. 修改prometheus配置文件</h2><p>修改配置文件prometheus.yml，将告警规则配置文件添加到prometheus.yml。注意路径。</p>
<pre><code>global:
  scrape_interval:     15s   # 这个是每次数据手机的频率
  evaluation_interval: 15s   # 评估告警规则的频率。

# Alertmanager configuration
alerting:
  alertmanagers:
  - static_configs:
    - targets:
       - &#39;localhost:9093&#39;

rule_files:
    - &quot;first_rules.yml&quot;
  # - &quot;second_rules.yml&quot;

scrape_configs:               # 通过这里的配置控制prometheus监控的资源
  - job_name: prometheus      # prometheus自身默认的
    static_configs:
      - targets: [&#39;localhost:9090&#39;]  # 默认暴露的是9090端口服务</code></pre><h2 id="3-配置告警规则文件"><a href="#3-配置告警规则文件" class="headerlink" title="3. 配置告警规则文件"></a>3. 配置告警规则文件</h2><blockquote>
<p>在告警规则文件中，我们可以将一组相关的规则设置定义在一个group下。在每一个group中我们可以定义多个告警规则(rule)。一条告警规则主要由以下几部分组成：<br><strong>alert</strong>：告警规则的名称。<br><strong>expr</strong>：基于PromQL表达式告警触发条件，用于计算是否有时间序列满足该条件。<br><strong>for</strong>：评估等待时间，可选参数。用于表示只有当触发条件持续一段时间后才发送告警。在等待期间新产生告警的状态为pending。<br><strong>labels</strong>：自定义标签，允许用户指定要附加到告警上的一组附加标签。<br><strong>annotations</strong>：用于指定一组附加信息，比如用于描述告警详细信息的文字等，annotations的内容在告警产生时会一同作为参数发送到Alertmanager。summary描述告警的概要信息，description用于描述告警的详细信息。同时Alertmanager的UI也会根据这两个标签值，显示告警信息。</p>
</blockquote>
<p>这里配置中的acs-ms为应用名字。也就是job的名字</p>
<h3 id="监控应用是否宕机，"><a href="#监控应用是否宕机，" class="headerlink" title="监控应用是否宕机，"></a>监控应用是否宕机，</h3><pre><code>alert: serverDown
expr: up{job=&quot;acs-ms&quot;}  ==  0
for: 1m
labels:
  severity: critical
annotations:
  description: 实例：{{ $labels.instance }} 宕机了
  summary: Instance {{ $labels.instance }} down</code></pre><h3 id="监控接口发生异常"><a href="#监控接口发生异常" class="headerlink" title="监控接口发生异常"></a>监控接口发生异常</h3><pre><code>alert: interface_request_exception
expr: increase(http_server_requests_seconds_count{exception!=&quot;None&quot;,exception!=&quot;ServiceException&quot;,job=&quot;acs-ms&quot;}[1m])
  &gt; 0
for: 1s
labels:
  severity: page
annotations:
  description: &#39;实例：{{ $labels.instance }}的{{$labels.uri}}的接口发生了{{ $labels.exception
    }}异常 &#39;
  summary: 监控一定时间内接口请求异常的数量</code></pre><blockquote>
<p><strong>exception!=”ServiceException”</strong> 是将一些手动抛出的自定义异常给排除掉。</p>
</blockquote>
<h3 id="监控接口请求时长"><a href="#监控接口请求时长" class="headerlink" title="监控接口请求时长"></a>监控接口请求时长</h3><pre><code>alert: interface_request_duration
expr: increase(http_server_requests_seconds_sum{exception=&quot;None&quot;,job=&quot;acs-ms&quot;,uri!~&quot;.*Excel.*&quot;}[1m])
  / increase(http_server_requests_seconds_count{exception=&quot;None&quot;,job=&quot;acs-ms&quot;,uri!~&quot;.*Excel.*&quot;}[1m])
  &gt; 5
for: 5s
labels:
  severity: page
annotations:
  description: &#39;实例：{{ $labels.instance }} 的{{$labels.uri}}接口请求时长超过了设置的阈值：5s，当前值{{
    $value }}s &#39;
  summary: 监控一定时间内的接口请求时长</code></pre><blockquote>
<p><strong>uri!~”.<em>Excel.</em>“</strong> 是将一些接口给排除掉。这个是将包含Excel的接口排除掉。</p>
</blockquote>
<h3 id="监测系统CPU使用的百分比"><a href="#监测系统CPU使用的百分比" class="headerlink" title="监测系统CPU使用的百分比"></a>监测系统CPU使用的百分比</h3><pre><code>alert: CPUTooHeight
expr: process_cpu_usage{job=&quot;acs-ms&quot;} &gt; 0.3
for: 15s
labels:
  severity: page
annotations:
  description: &#39;实例：{{ $labels.instance }} 的cpu超过了设置的阈值：30%，当前值{{ $value }} &#39;
  summary: 监测系统CPU使用的百分比</code></pre><h3 id="监控tomcat活动线程占总线程的比例"><a href="#监控tomcat活动线程占总线程的比例" class="headerlink" title="监控tomcat活动线程占总线程的比例"></a>监控tomcat活动线程占总线程的比例</h3><pre><code>alert: tomcat_thread_height
expr: tomcat_threads_busy_threads{job=&quot;acs-ms&quot;}
  / tomcat_threads_config_max_threads{job=&quot;acs-ms&quot;} &gt; 0.5
for: 15s
labels:
  severity: page
annotations:
  description: &#39;实例：{{ $labels.instance }} 的tomcat活动线程占总线程的比例超过了设置的阈值：50%，当前值{{ $value
    }} &#39;
  summary: 监控tomcat活动线程占总线程的比例</code></pre><h2 id="4-启动Prometheus使配置生效"><a href="#4-启动Prometheus使配置生效" class="headerlink" title="4. 启动Prometheus使配置生效"></a>4. 启动Prometheus使配置生效</h2><pre><code>./prometheus --config.file=prometheus.yml</code></pre><h2 id="5-查看告警规则配置"><a href="#5-查看告警规则配置" class="headerlink" title="5. 查看告警规则配置"></a>5. 查看告警规则配置</h2><p> 访问：<strong><a href="http://ip:port:9090/rules">http://ip:port:9090/rules</a></strong></p>
]]></content>
      <categories>
        <category>prometheus</category>
      </categories>
      <tags>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring注解介绍</title>
    <url>/2020/07/01/spring-zhu-jie/</url>
    <content><![CDATA[<ol>
<li>@Controller    组合注解（组合了@Component注解），应用在MVC层（控制层）,DispatcherServlet会自动扫描注解了此注解的类，然后将web请求映射到注解了@RequestMapping的方法上。</li>
<li>@Service    组合注解（组合了@Component注解），应用在service层（业务逻辑层）</li>
<li>@Reponsitory    组合注解（组合了@Component注解），应用在dao层（数据访问层）</li>
<li>@Component    表示一个带注释的类是一个“组件”，成为Spring管理的Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component还是一个元注解。</li>
<li>@Autowired    Spring提供的工具（由Spring的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入。）</li>
<li>@Resource    JSR-250提供的注解</li>
<li>@Inject    JSR-330提供的注解</li>
<li>@Configuration    声明当前类是一个配置类（相当于一个Spring配置的xml文件）</li>
<li>@ComponentScan    自动扫描指定包下所有使用</li>
<li>@Service,@Component,@Controller,@Repository的类并注册</li>
<li>@Bean    注解在方法上，声明当前方法的返回值为一个Bean。返回的Bean对应的类中可以定义init()方法和destroy()方法，然后@Bean(initMethod=“init”,destroyMethod=“destroy”)定义，在构造之后执行init，在销毁之前执行destroy。</li>
<li>@Aspect    声明一个切面（就是说这是一个额外功能）</li>
<li>@After    后置建言（advice），在原方法前执行。</li>
<li>@Before    前置建言（advice），在原方法后执行。</li>
<li>@Around    环绕建言（advice），在原方法执行前执行，在原方法执行后再执行（@Around可以实现其他两种advice）</li>
<li>@PointCut    声明切点，即定义拦截规则，确定有哪些方法会被切入</li>
<li>@Transactional    声明事务（一般默认配置即可满足要求，当然也可以自定义）</li>
<li>@Cacheable    声明数据缓存</li>
<li>@EnableAspectJAutoProxy    开启Spring对AspectJ的支持</li>
<li>@Value    值得注入。经常与Sping EL表达式语言一起使用，注入普通字符，系统属性，表达式运算结果，其他Bean的属性，文件内容，网址请求内容，配</li>
<li>文件属性值等等</li>
<li>@PropertySource    指定文件地址。提供了一种方便的、声明性的机制，用于向Spring的环境添加PropertySource。与@configuration类一起使用。</li>
<li>@PostConstruct    标注在方法上，该方法在构造函数执行完成之后执行。</li>
<li>@PreDestroy    标注在方法上，该方法在对象销毁之前执行。@Profile    表示当一个或多个指定的文件是活动的时，一个组件是有资格注册的。使用@Profile注解类或者方法，达到在不同情况下选择实例化不同的Bean。</li>
<li>@Profile(“dev”)表示为dev时实例化。</li>
<li>@EnableAsync    开启异步任务支持。注解在配置类上。</li>
<li>@Async    注解在方法上标示这是一个异步方法，在类上标示这个类所有的方法都是异步方法。</li>
<li>@EnableScheduling    注解在配置类上，开启对计划任务的支持。</li>
<li>@Scheduled    注解在方法上，声明该方法是计划任务。支持多种类型的计划任务：cron,fixDelay,fixRate</li>
<li>@Conditional    根据满足某一特定条件创建特定的Bean</li>
<li>@Enable*    通过简单的@Enable来开启一项功能的支持。所有@Enable注解都有一个@Import注解，@Import是用来导入配置类的，这也就意味着这些自动开启的实现其实是导入了一些自动配置的Bean(1.直接导入配置类2.依据条件选择配置类3.动态注册配置类)</li>
<li>@RunWith    这个是Junit的注解，springboot集成了junit。一般在测试类里使用:@RunWith(SpringJUnit4ClassRunner.class) — SpringJUnit4ClassRunner在JUnit环境下提供Sprng TestContext Framework的功能</li>
<li>@ContextConfiguration    用来加载配置ApplicationContext，其中classes属性用来加载配置类:@ContextConfiguration(classes = {TestConfig.class(自定义的一个配置类)})</li>
<li>@ActiveProfiles    用来声明活动的profile–@ActiveProfiles(“prod”(这个prod定义在配置类中))</li>
<li>@EnableWebMvc    用在配置类上，开启SpringMvc的Mvc的一些默认配置：如ViewResolver，MessageConverter等。同时在自己定制SpringMvc的相关配置时需要做到两点：1.配置类继承WebMvcConfigurerAdapter类2.就是必须使用这个@EnableWebMvc注解。</li>
<li>@RequestMapping    用来映射web请求（访问路径和参数），处理类和方法的。可以注解在类和方法上，注解在方法上的@RequestMapping路径会继承注解在类上的路径。同时支持Serlvet的request和response作为参数，也支持对request和response的媒体类型进行配置。其中有value(路径)，produces(定义返回的媒体类型和字符集)，method(指定请求方式)等属性。</li>
<li>@GetMapping    GET方式的@RequestMapping</li>
<li>@PostMapping    POST方式的@RequestMapping</li>
<li>@ResponseBody    将返回值放在response体内。返回的是数据而不是页面</li>
<li>@RequestBody    允许request的参数在request体中，而不是在直接链接在地址的后面。此注解放置在参数前。</li>
<li>@PathVariable    放置在参数前，用来接受路径参数。</li>
<li>@RestController    组合注解，组合了@Controller和@ResponseBody,当我们只开发一个和页面交互数据的控制层的时候可以使用此注解。</li>
<li>@ControllerAdvice    用在类上，声明一个控制器建言，它也组合了@Component注解，会自动注册为Spring的Bean。</li>
<li>@ExceptionHandler    用在方法上定义全局处理，通过他的value属性可以过滤拦截的条件：@ExceptionHandler(value=Exception.class)–表示拦截所有Exception。</li>
<li>@ModelAttribute    将键值对添加到全局，所有注解了@RequestMapping的方法可获得次键值对（就是在请求到达之前，往model里addAttribute一对name-value而已）。</li>
<li>@InitBinder    通过@InitBinder注解定制WebDataBinder（用在方法上，方法有一个WebDataBinder作为参数，用WebDataBinder在方法内定制数据绑定，例如可以忽略request传过来的参数Id等）。</li>
<li>@WebAppConfiguration    一般用在测试上，注解在类上，用来声明加载的ApplicationContext是一个WebApplicationContext。他的属性指定的是Web资源的位置，默认为src/main/webapp,我们可以修改为：@WebAppConfiguration(“src/main/resources”)。</li>
<li>@EnableAutoConfiguration    此注释自动载入应用程序所需的所有Bean——这依赖于Spring Boot在类路径中的查找。该注解组合了@Import注解，@Import注解导入了EnableAutoCofigurationImportSelector类，它使用SpringFactoriesLoader.loaderFactoryNames方法来扫描具有META-INF/spring.factories文件的jar包。而spring.factories里声明了有哪些自动配置。</li>
<li>@SpingBootApplication    SpringBoot的核心注解，主要目的是开启自动配置。它也是一个组合注解，主要组合了@Configurer，@EnableAutoConfiguration（核心）和@ComponentScan。可以通过@SpringBootApplication(exclude={想要关闭的自动配置的类名.class})来关闭特定的自动配置。</li>
<li>@ImportResource    虽然Spring提倡零配置，但是还是提供了对xml文件的支持，这个注解就是用来加载xml配置的。例：@ImportResource({“classpath</li>
<li>@ConfigurationProperties    将properties属性与一个Bean及其属性相关联，从而实现类型安全的配置。例：@ConfigurationProperties(prefix=“authot”，locations={“classpath</li>
<li>@ConditionalOnBean    条件注解。当容器里有指定Bean的条件下。</li>
<li>@ConditionalOnClass    条件注解。当类路径下有指定的类的条件下。</li>
<li>@ConditionalOnExpression    条件注解。基于SpEL表达式作为判断条件。</li>
<li>@ConditionalOnJava    条件注解。基于JVM版本作为判断条件。</li>
<li>@ConditionalOnJndi    条件注解。在JNDI存在的条件下查找指定的位置。</li>
<li>@ConditionalOnMissingBean    条件注解。当容器里没有指定Bean的情况下。</li>
<li>@ConditionalOnMissingClass    条件注解。当类路径下没有指定的类的情况下。</li>
<li>@ConditionalOnNotWebApplication    条件注解。当前项目不是web项目的条件下。</li>
<li>@ConditionalOnResource    条件注解。类路径是否有指定的值。</li>
<li>@ConditionalOnSingleCandidate    条件注解。当指定Bean在容器中只有一个，后者虽然有多个但是指定首选的Bean。</li>
<li>@ConditionalOnWebApplication    条件注解。当前项目是web项目的情况下。</li>
<li>@EnableConfigurationProperties    注解在类上，声明开启属性注入，使用@Autowired注入。例：@EnableConfigurationProperties(HttpEncodingProperties.class)。</li>
<li>@AutoConfigureAfter    在指定的自动配置类之后再配置。例：@AutoConfigureAfter(WebMvcAutoConfiguration.class)</li>
</ol>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo写博客</title>
    <url>/2022/06/11/shi-yong-hexo-xie-bo-ke/</url>
    <content><![CDATA[<h1 id="使用hexo写博客"><a href="#使用hexo写博客" class="headerlink" title="使用hexo写博客"></a>使用hexo写博客</h1><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>node的版本号一定要正确，不然可能会出现版本不适配等一系列问题。这里node使用12.18.3版本</p>
<p>node下载：<a href="https://nodejs.org/download/release/v12.18.3/" target="_blank" rel="noopener">https://nodejs.org/download/release/v12.18.3/</a></p>
<p>下载文件为：node-v12.18.3-x64.msi </p>
<pre><code>git version
node -v
npm -v</code></pre><h2 id="npm缓存清除"><a href="#npm缓存清除" class="headerlink" title="npm缓存清除"></a>npm缓存清除</h2><pre><code>npm cache clean --force</code></pre><h2 id="npm镜像"><a href="#npm镜像" class="headerlink" title="npm镜像"></a>npm镜像</h2><p>国内npm比较慢，安装cnpm淘宝镜像</p>
<pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><h2 id="重新生成node-modules"><a href="#重新生成node-modules" class="headerlink" title="重新生成node_modules"></a>重新生成node_modules</h2><pre><code>rm -rf node_modules &amp;&amp; npm install --force</code></pre><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><pre><code>npm install -g hexo-cli</code></pre><h2 id="部署插件"><a href="#部署插件" class="headerlink" title="部署插件"></a>部署插件</h2><pre><code>npm install hexo-deployer-git --save</code></pre><h2 id="使用以及部署"><a href="#使用以及部署" class="headerlink" title="使用以及部署"></a>使用以及部署</h2><pre><code>hexo clean #清理各种缓存和旧文件
hexo g     #生成静态文件
hexo s     #开启服务器预览
hexo d     #部署到git服务器上</code></pre>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用rocketmq-spring-boot-starter发送，消费消息的简单示例</title>
    <url>/2021/04/02/shi-yong-rocketmq-spring-boot-starter-fa-song-xiao-fei-xiao-xi-de-jian-dan-shi-li/</url>
    <content><![CDATA[<h1 id="使用rocketmq-spring-boot-starter发送，消费消息的简单示例"><a href="#使用rocketmq-spring-boot-starter发送，消费消息的简单示例" class="headerlink" title="使用rocketmq-spring-boot-starter发送，消费消息的简单示例"></a>使用rocketmq-spring-boot-starter发送，消费消息的简单示例</h1><h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h2><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> rokcetmq starter  <span class="token operator">--</span><span class="token operator">></span>
<span class="token operator">&lt;</span>dependency<span class="token operator">></span>
    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>rocketmq<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>
    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>rocketmq<span class="token operator">-</span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>
    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">2.2</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre>
<h2 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h2><pre class=" language-java"><code class="language-java"># application<span class="token punctuation">.</span>properties
rocketmq<span class="token punctuation">.</span>name<span class="token operator">-</span>server<span class="token operator">=</span><span class="token number">139.224</span><span class="token punctuation">.</span><span class="token number">103.236</span><span class="token operator">:</span><span class="token number">9876</span>
rocketmq<span class="token punctuation">.</span>producer<span class="token punctuation">.</span>group<span class="token operator">=</span>spring<span class="token operator">-</span>application<span class="token operator">-</span>name</code></pre>
<h2 id="3-生产者发送消息"><a href="#3-生产者发送消息" class="headerlink" title="3. 生产者发送消息"></a>3. 生产者发送消息</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 引入rocketMQTemplate</span>
<span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">private</span> RocketMQTemplate rocketMQTemplate<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 通过rocketMQTemplate发送消息。</span>
<span class="token comment" spellcheck="true">// destination: formats: `topicName:tags`</span>
<span class="token comment" spellcheck="true">// payload: 消息内容</span>
rocketMQTemplate<span class="token punctuation">.</span><span class="token function">syncSend</span><span class="token punctuation">(</span><span class="token string">"CSS:ORDER_CANCEL"</span><span class="token punctuation">,</span> <span class="token string">"orderId-111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h2 id="4-消费者接受消息"><a href="#4-消费者接受消息" class="headerlink" title="4. 消费者接受消息"></a>4. 消费者接受消息</h2><p>消费的的依赖和配置文件同生产者一样。组名修改即可。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span>
<span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@RocketMQMessageListener</span><span class="token punctuation">(</span>topic <span class="token operator">=</span> <span class="token string">"CSS"</span><span class="token punctuation">,</span> selectorExpression <span class="token operator">=</span> <span class="token string">"ORDER_CANCEL"</span><span class="token punctuation">,</span> consumerGroup <span class="token operator">=</span> <span class="token string">"spring-application-name"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestConsumer</span> <span class="token keyword">implements</span> <span class="token class-name">RocketMQListener</span><span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onMessage</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Receive message："</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 业务逻辑处理。。。</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文对Spring项目里面对RocketMQ发送消息和消费消息，进行了简单的示例说明。方便大家入门使用！</p>
<p>实际项目中。有能力的公司一般都会对RocketMQ进行二次封装，将RocketMQ的用法化繁为简。</p>
<p>后面会陆续介绍RocketMQ的高级用法。</p>
]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>《高性能MySQL》读书笔记</title>
    <url>/2018/11/10/gao-xing-neng-mysql-du-shu-bi-ji/</url>
    <content><![CDATA[<p>不求甚解的读书和不读有何区别<br>                                             —— 江峰</p>
<h2 id="第1章-MySQL架构与历史"><a href="#第1章-MySQL架构与历史" class="headerlink" title="第1章 MySQL架构与历史"></a>第1章 MySQL架构与历史</h2><p>下载sakila数据库结构文件和数据文件：<a href="https://dev.mysql.com/doc/index-other.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/index-other.html</a></p>
<h3 id="1-1-MySQL逻辑架构"><a href="#1-1-MySQL逻辑架构" class="headerlink" title="1.1 MySQL逻辑架构"></a>1.1 MySQL逻辑架构</h3><p><strong>查询缓存</strong></p>
<p>对于select语句，在解析查询之前，服务器会先检查缓存，如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。</p>
<h3 id="1-2-并发控制"><a href="#1-2-并发控制" class="headerlink" title="1.2 并发控制"></a>1.2 并发控制</h3><p>​    1.<strong>读写锁</strong>（又称共享锁和排他锁）：都是行级锁。<br>​        读锁是共享的，相互不阻塞。多个客户在同一时刻可以读取同一个资源,而互补干扰。读的时候不能修改数据。<br>​        写锁是排他的，也就是说一个写锁会阻塞其他的写锁和读锁。在同一时刻，只有一个用户能进行写入，并防止其他用户读取正在写入的统一资源。</p>
<p>​    2.<strong>锁粒度</strong>：尽量只锁定需要修改的部分数据，而不是所有的资源。锁定的数据量越小，则系统的并发程度越高。加锁本身也需要消耗资源。<br>​        锁策略：就是在锁的开销和数据的安全性之间寻求平衡，这种平衡也会影响到性能。锁策略有表锁和行级锁等。</p>
<p>​    3.<strong>表锁</strong>：是最基本的锁策略，也是开销最小的策略，它会锁定整张表，对表进行写操作（插入，删除，修改），都需要先获取写锁，并阻塞其他用户<br>​            对该表的读写操作。只有没有写锁时，其他用户才能获取读锁，读锁之间是不会相互阻塞的。<br>​            注意：写锁具有比读锁更高的优先级（写锁可以插入到锁队列中读锁的前面，反之读锁则不能插入到写锁的前面）。</p>
<p>​    4.<strong>行级锁</strong>：行级锁可以最大程度的支持并发处理(同时也带来了最大的锁开销)，行级锁只在存储引擎层实现，而MySQL服务器层没有实现。服务器从完全不了解存储引擎中的锁实现。</p>
<h3 id="1-3-事务（ACID）"><a href="#1-3-事务（ACID）" class="headerlink" title="1.3 事务（ACID）"></a>1.3 事务（ACID）</h3><p>事务就是一组原子性的SQL查询，或者说一个独立的工作单元。事务内的语句，要不全部执行成功，要么全部执行失败。一个实现了ACID的数据库，通常需要更高的性能。所以用户需要根据是否需要事务处理，来选择合适的存储引擎。</p>
<p><strong>原子性**</strong>：事务是不可分割的最小的执行单元，一个事务中的所有操作要么全部执行成功，要么全部执行失败。<br><strong>一致性</strong>：数据库总是从一个一致性的状态转换到另外一个一致性的状态。<br><strong>隔离性</strong>：通常来说，一个事务所做的修改在最终提交以前，对其他事务来说是不可见的。<br><strong>持久性</strong>：一旦事务提交，则其所做的修改就会永久的被保存到数据库中。</p>
<p><strong>1.隔离级别：</strong></p>
<p><strong>读未提交</strong>：事务中修改，即使没有提交，对其他事务也都是可见的。<br><strong>读已提交</strong>：一个事务从开始到提交之前，对其他事务是不可见的。它是一个事务，要等另一个事务提交后才能读取数据。它可能出现不可重复读。（大多数数据库的隔离级别，如SqlServer,Oracle等）<br><strong>可重复读</strong>：解决了脏读的问题，并保证了在同一个事务中中多次读取同样的记录的结果是一致的。（MySQL默认的隔离级别）<br><strong>串行化</strong>：强制事务串行执行，避免了幻读的问题。SERIALIZABLE会在读取的每一行数据上都加锁。（性能消耗很高）</p>
<p><strong>2.死锁：</strong></p>
<p><strong>指两个或多个事务对同一资源相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</strong></p>
<p><strong>解决办法：死锁检测和死锁超时机制</strong><br>​       InnoDB处理死锁的办法是：将持有最少行级排它锁的事务进行回滚。<br>​       锁的行为和顺序是和执行引擎有关系的，死锁发生以后，只有部分或完全回滚其中一个事务，才能打破事务。</p>
<p><strong>3.事务日志</strong></p>
<p>事务日志可以帮助提高使用事务的效率。使用事务日志，存储引擎在修改表数据的时候只需要修改其内存拷贝，再将该修改行为持久化到硬盘中的事务日志中，而不是每次都将数据本身持久化到磁盘。事务持久以后，内存中被修改的数据在后台可以慢慢的刷会磁盘。所以修改数据需要写两次磁盘。</p>
<p><strong>4.MySQL中的事务：</strong> </p>
<ol>
<li><strong>自动提交</strong>：MySQL默认采用自动提交（AUTOCOMMIT）模式，也就是说，如果不是显式的开启一个事务，则每个sql语句都被当做一个事务执行提交动作。<br>​当set autocommit = 0时，所有的sql语句都是在一个事务当中，直到执行commit或rollback。该事务结束，同时又开启了另一个事务。</li>
<li>在事务中混合使用存储引擎：MySQL服务器层是不管理事务的，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。</li>
<li><strong>隐式和显式锁定：InnoDB采用的是两阶段锁定协议。</strong><br><strong>​select … lock in share mode; 加共享锁</strong><br><strong>​select … for update; 加排它锁</strong></li>
</ol>
<h3 id="1-4-多版本并发控制（MVCC）"><a href="#1-4-多版本并发控制（MVCC）" class="headerlink" title="1.4 多版本并发控制（MVCC）"></a><strong>1.4 多版本并发控制（MVCC）</strong></h3><p>MVCC的实现，是通过保存数据在某个给时间点的快照来实现的。</p>
<h3 id="1-5-MySQL中的存储引擎"><a href="#1-5-MySQL中的存储引擎" class="headerlink" title="1.5 MySQL中的存储引擎"></a>1.5 MySQL中的存储引擎</h3><p><strong>show table status查看表的状态信息;</strong></p>
<ol>
<li><p><strong>InnoDB存储引擎</strong>：<strong>InnoDB采用MVCC来支持高并发</strong>，并且实现了四个标准的隔离级别。<br> InnoDB表是基于聚族索引建立的，聚族索引对主键查询有很高的性能。</p>
</li>
<li><p><strong>MyISAM存储引擎</strong>:不支持事务，不支持行级锁，且崩溃后无法安全恢复</p>
<p><strong>MyISAM特性：</strong></p>
<ol>
<li>加锁与并发：MyISAM对整张表加锁，而不是针对行。读取时对需要读取的所有表加共享锁，写入时则对表加排它锁。并在读取的时候也支持插入（称为并发插入）</li>
<li>修复：MySQL可以手工或者自动执行检查和修复操作，执行表的修复可能会导致部分数据丢失，并且修复操作是非常慢的。</li>
<li>索引特性：对于MyISAM表，即使是BLOB和TEXT等长字段，也可以基于前500个字符创建索引，MyISAM也支持全文索引，支持复杂查询。</li>
<li>延迟更新索引键：如果开启了DELY_KEY_WRITE选项，在每次修改的时候，不会立即将修改的索引数据更新到磁盘，而是会写到内存中的键缓冲区。清理缓冲区或关闭表的时候才会写入到磁盘，提高了写入的性能。</li>
<li>MyISAM压缩表：支持索引，压缩表不能修改（除非先。解压缩，在修改，再压缩）。可以减少磁盘IO,提升查询性能。</li>
<li>MyISAM性能：最典型的性能问题是表锁的问题，如果发现所有的查询都长期处于 “locked” 的状态，那么毫无疑问表锁就是罪魁祸首。</li>
</ol>
</li>
<li><p><strong>MySQL内建的其他存储引擎</strong></p>
</li>
<li><p><strong>第三方存储引擎</strong></p>
</li>
<li><p><strong>选择合适的存储引擎</strong>：</p>
<p><strong>除非用到某些InnoDB不具备的特性，并且没有其他办法替代，否则都应该优先考虑使用InnoDB引擎。</strong></p>
<p><strong>事务</strong>：如果需要事务，选择InnoDB，不需要事务，并且主要是INSERT 和 SELECT操作，那么MyISAM是不错的选择。<br><strong>备份</strong>：如果可以定期的关闭服务器进行备份，那么备份的因素可以忽略。反之，如果需要热备份，那么选择InnoDB引擎。<br><strong>崩溃恢复</strong>：MyISAM崩溃恢复后发生损坏的概率比InnoDB高的多，而且恢复速度也很慢，所以即时不需要支持事务，很多人也选择InnoDB，这是一个很重要的因素。<br><strong>日志型应用</strong>：对插入速度有很高的要求，可以考虑使用MyISAM，开销低，插入快。只读或者大部分情况下只读的表：读多写少的业务，如果不介意MyISAM的崩溃恢复，选用MyISAM是合适的。不要低估崩溃后恢复问题的重要性（MySIAM引擎是只将数据写到内存中，然后操作系统定期将数据刷到磁盘中）。<br><strong>订单处理</strong>：涉及到订单处理，那么支持事务就是必须选项。InnoDB是支持订单处理的最佳选择。<br><strong>电子公告牌和主题讨论论坛</strong>：如select count(<em>) from table;对MyISAM是比较快的，但对于其他的存储引擎可能都不行。<br>*</em>大数据量**：几个TB的数据量，需要合理的选择硬件，做好物理涉及，并对服务器的I/O瓶颈做好规划。在这样的数据量下，如果选用MyISAM，如果崩溃了，那么进行数据恢复基本就是凉凉。</p>
</li>
<li><p><strong>转换表的存储引擎：</strong></p>
<ol>
<li><strong>ALTER TABLE：比如将myTable表的存储引擎换成InnoDB,</strong><br>CREATE TABLE innodb_table like myTable;<br>ALTER TABLE innodb_table ENGINE = INNODB;<br>INSERT INTO innodb_table SELECT * FROM myTable;<br>该操作是按行将数据从这张表复制到另一张表中，需要执行很长的时间，在复制期间可能会消耗系统所有的I/O能力，同时会在原表加上读锁。所以在繁忙的表上执行此操作需要小心。</li>
<li><strong>导出与导入</strong>：使用mysqldump工具将数据导出到文件等操作。</li>
<li><strong>创建与查询(CREATE 和 SELECT)</strong>：创建一个新的存储引擎的表，然后将数据导入到新表。数据量大的话就需要分批处理。 这样操作以后，新表就是原表的一个复制。如果有必要，可以在执行的过程中对原表加锁。</li>
</ol>
</li>
</ol>
<h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><p>MySQL拥有分层的架构。上层是服务器层的服务和查询执行引擎，下层则是执行引擎。等等。。。（对于InnoDB来说，所有的提交都是事务）</p>
<h2 id="第2章-MySQL基准测试"><a href="#第2章-MySQL基准测试" class="headerlink" title="第2章 MySQL基准测试"></a>第2章 MySQL基准测试</h2><h3 id="2-1-为什么要有基准测试"><a href="#2-1-为什么要有基准测试" class="headerlink" title="### 2.1 为什么要有基准测试"></a>### 2.1 为什么要有基准测试</h3><p>对系统的性能做出一个大概的评估， TPS(每秒事务数)</p>
<h3 id="2-2-基准测试的策略"><a href="#2-2-基准测试的策略" class="headerlink" title="2.2 基准测试的策略"></a>2.2 基准测试的策略</h3><p>主要有两种，一种是对整个系统进行测试（集成式基准测试），二是单独测试MySQL(单组件式基准测试)。</p>
<p>测试何种指标：</p>
<ol>
<li>吞吐量：指的是单位时间内的事务处理数。</li>
<li>响应时间或延迟：这个指标用于测试任务所需的整体时间。计算出平均响应时间、最小响应时间、最大响应时间和所占百分比等。</li>
<li>并发性：Web服务器的并发性也不等同于数据库的并发性，而仅仅表示回话存储机制能够处理多少数据的能力。Web服务器的并发性更正确的度量指标，应该是在任意时间有多少同时发生的并发请求。Web服务器的高并发，一般也会导致数据库的高并发。</li>
<li>可拓展性：</li>
</ol>
<p>归根结底，应该测试那些对用户来说最重要的指标。</p>
<h3 id="2-3-基准测试方法"><a href="#2-3-基准测试方法" class="headerlink" title="2.3 基准测试方法"></a>2.3 基准测试方法</h3><p>测试中一些常见的错误，见书82页</p>
<h2 id="第3章-服务器性能分析"><a href="#第3章-服务器性能分析" class="headerlink" title="第3章 服务器性能分析"></a>第3章 服务器性能分析</h2><h3 id="3-1-性能优化简介"><a href="#3-1-性能优化简介" class="headerlink" title="3.1 性能优化简介"></a>3.1 性能优化简介</h3><p>性能即响应时间。数据库服务器的目的是执行SQL语句，所以它关注的应该是查询或者语句，如SELECT,UPDATE ,DELETE等。<br>数据库的性能用查询的响应时间来度量，单位是每个查询花费的时间。</p>
<h3 id="3-2-对应用程序进行进行性能剖析"><a href="#3-2-对应用程序进行进行性能剖析" class="headerlink" title="3.2 对应用程序进行进行性能剖析"></a>3.2 对应用程序进行进行性能剖析</h3><h3 id="3-3-剖析MySQL查询"><a href="#3-3-剖析MySQL查询" class="headerlink" title="3.3 剖析MySQL查询"></a>3.3 剖析MySQL查询</h3><ol>
<li><strong>剖析服务器负载</strong></li>
<li><strong>剖析单条查询</strong><pre><code>    set profiling = 1; 打开测量服务器中运行的所有的语句的运行时间，默认关闭。
    show profiles; 显示SQL语句的运行时间。（会发现每条语句都会创建一个id）
    show profile for query [id]; 详细显示这条语句（id）的运行时间</code></pre></li>
</ol>
<p>​         show status本身也会创建一条临时表</p>
<ol start="3">
<li><strong>使用性能剖析</strong></li>
</ol>
<h3 id="3-4-诊断间歇性问题"><a href="#3-4-诊断间歇性问题" class="headerlink" title="3.4 诊断间歇性问题"></a>3.4 诊断间歇性问题</h3><p>比如系统偶尔停顿或者慢查询。<br>    1.使用 SHOW GLOBAL STATUS</p>
<h2 id="第4章-Schema与数据类型优化"><a href="#第4章-Schema与数据类型优化" class="headerlink" title="第4章 Schema与数据类型优化"></a>第4章 Schema与数据类型优化</h2><p>​    </p>
<h3 id="4-1-选择优化的数据类型"><a href="#4-1-选择优化的数据类型" class="headerlink" title="4.1 选择优化的数据类型"></a>4.1 选择优化的数据类型</h3><ol>
<li><p><strong>更小的通常更好</strong>：一般情况下，应该选择正确存储数据的最小数据类型。（占用更少的磁盘、内存、CPU缓存）</p>
</li>
<li><p><strong>简单就好</strong>：简单数据类型的操作通常需要更少的CPU周期,整形比字符型操作代价更低（因为字符集和校对规则使字符比较比整型比较要复杂）</p>
<p>例子1：应该使用MySQL内建的类型(timeStamp,dateTime)，而不是字符串来存储日期和时间。<br>例子2：应该使用整型来存储IP地址。</p>
</li>
<li><p><strong>尽量避免NULL</strong>：因为可为NULL的列使得索引，索引统计，和值都比较复杂。导致更难优化，把可为NULL的列改为非NULL能带来性能上的提升。</p>
</li>
<li><p><strong>数据类型</strong></p>
<p>在为列选择数据类型时：</p>
<p>第一步，选择合适的大类型。数字、字符串、时间等。<br>第二步，选择具体类型。很多MySQL的数据类型可以存储相同的数据，只是存储的范围，精度或占用磁盘和内存空间不同。</p>
<ol>
<li><p>整型类型：TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT。分别占用8位、16、24、32、64位存储空间。</p>
<p><strong>整数类型有可选的UNSIGNED属性，表示不允许负数。</strong></p>
<p>这大致可以使整数的上限大概提升一倍。有符号类型与无符号类型占用相同的存储空间，并具有相同的性能，因此根据实际情况选择合适的数据类型。<br>MySQL可以为整数类型指定宽度：例如int(11),对大多数应用来说，是没有意义的：它不会限制值得合法范围，只是规定了MySQL的一些（例如MySQ命令行客户端）用来显示字符的个数。对于存储和计算来说，INT(1)和INT(20)来说是一样的。</p>
</li>
<li><p>实数类型：实数是带有小数部分的数字。FLOAT,DOUBLE是浮点类型，DECIMAL类型（需要额外的空间和计算开销，要慎用）。</p>
</li>
<li><p>字符串类型：</p>
<p><strong>VARCHAR</strong>：存储可变长字符串，是最常见的字符串类型。它比定长类型更节省空间，因为它使用必要的空间（例如，越短的字符串使用越少的空间）。VARCHAR需要1或2个额外字节记录字符串的长度<br><strong>CHAR</strong>：定长的，MySQL根据定义的字符串长度分配足够的空间。CHAR适合存储很短的字符串或者所有值都接近同一个长度。</p>
<p>通常情况下使用varchar(20)和varchar(255)保持’hello’占用的空间都是一样的，但使用长度较短的列却有巨大的优势。</p>
<p>较大的列使用更多的内存，因为MySQL通常会分配固定大小的内存块来保存值，这对排序或使用基于内存的临时表尤其不好。</p>
<p>同样的事情也会发生在使用文件排序或者基于磁盘的临时表的时候。</p>
<p><strong>BLOB和TEXT类型</strong>：都是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。</p>
<p>如果查询使用了BLOB或TEXT列并且需要使用隐士临时表，将会使用磁盘临时表。这会导致严重的性能开销。使用枚举（ENUM）代替字符串类型：</p>
</li>
<li><p><strong>日期和时间类型</strong></p>
<p><strong>DATETIME</strong>:精度为秒，默认情况下，MySQL以一种可排序的，无歧义的格式显示DATETIME值，与时区无关，使用8个字节的存储空间。例如：” 2018-11-14 10:49:00 “。</p>
<p><strong>TIMESTAMP</strong>：占4个字节的存储空间， 通常情况下，应该尽量使用TIMESTAMP而不是DATETIME，因为它比DATETIME占用空间更小。</p>
</li>
<li><p><strong>位数据类型</strong>：从技术来说都是字符串类型。</p>
<ol>
<li>BIT：最好不要使用</li>
<li>SET：缺点是改变列的代价太高。</li>
<li>在整数列上进行按位操作：</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>​    6.选择标识符：<br>​        数据库中schema指的是数据库的组织和结构。如ORM自动生成的schema可能不会存储任意的数据类型，所以要检查清楚。避免性能问题。<br>​        ip地址使用无符号整型：unsigned int(10)来存储就行了。原因：数值型比字符串效率好。查询快，占用更小的内存空间等。</p>
<p>​    7.特殊类型数据：某些数据的类型并不直接与内置类型一致。</p>
<h3 id="4-2-MySQL-schema-设计中的陷阱"><a href="#4-2-MySQL-schema-设计中的陷阱" class="headerlink" title="4.2 MySQL schema 设计中的陷阱"></a>4.2 MySQL schema 设计中的陷阱</h3><p>​        <strong>太多的列</strong>：API进行工作时，会在服务器层和存储引擎层之间进行行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。字段太多的话，转换代价就会很高。<br>​        <strong>太多的关联</strong>：一个粗略的经验法则，如果希望查询执行的快速且并发性好，单个查询最好在12个表以内做关联。但阿里巴巴开发手册，严禁超过三张表以上做关联。    </p>
<h3 id="4-3-范式和反范式"><a href="#4-3-范式和反范式" class="headerlink" title="4.3 范式和反范式"></a>4.3 范式和反范式</h3><p>​    1.范式的优点很多，缺点是通常需要关联，这不但代价昂贵，且有可能使一些索引策略失效。<br>​    2.反范式的schema因为所有的数据都在一张表里面，可以很好的避免关联。</p>
<h3 id="4-4-缓存表和汇总表"><a href="#4-4-缓存表和汇总表" class="headerlink" title="4.4 缓存表和汇总表"></a>4.4 缓存表和汇总表</h3><h3 id="4-5-加快ALTER-TABLE操作的速度"><a href="#4-5-加快ALTER-TABLE操作的速度" class="headerlink" title="4.5 加快ALTER TABLE操作的速度"></a>4.5 加快ALTER TABLE操作的速度</h3><p>​    ALTER TABLE操作对于大表性能上是个问题。因为ALTER TABLE 是用新的结构创建一个新表，从旧表汇总查出所有数据插入到新表中，然后删除旧表。</p>
<h2 id="第5章-创建高性能上的索引"><a href="#第5章-创建高性能上的索引" class="headerlink" title="第5章 创建高性能上的索引"></a>第5章 创建高性能上的索引</h2><p><strong>（很重要，得再看一遍）</strong></p>
<p><strong>索引是存储引擎快速找到记录的一种数据结构，在MySQL中，首先在索引中找到对应值，然后在根据匹配到的索引记录找到对应的数据行。</strong></p>
<h3 id="5-1-索引的类型"><a href="#5-1-索引的类型" class="headerlink" title="5.1 索引的类型"></a>5.1 索引的类型</h3><h4 id="5-1-1-B-Tree索引"><a href="#5-1-1-B-Tree索引" class="headerlink" title="5.1.1 B-Tree索引"></a>5.1.1 B-Tree索引</h4><p>B-Tree索引是对索引列是顺序存储的。搜索时从根节点开始判断，不断比较直到找到叶子节点的索引值。只有叶子节点的索引才对应的数据行。</p>
<p> <strong>可以使用B-Tree索引查询的类型：</strong><br>​            全值匹配<br>​            匹配最左前缀<br>​            匹配列前缀<br>​            匹配范围值<br>​            精确匹配某一列并范围匹配另外一列</p>
<p><strong>B-Tree索引的限制</strong></p>
<ol>
<li><p>如果不是按照索引的最左列开始查找，则无法使用索引。</p>
</li>
<li><p>不能跳过索引中的列</p>
</li>
<li><p>如果查询中有某个列的范围查询，则其右边所有的列都无法使用索引优化查询。</p>
<p><strong>根据索引查询时只能从第一个索引列开始依次次往后开始查询，所以建立索引是索引的列的顺序是非常重要的。</strong></p>
</li>
</ol>
<h4 id="5-1-2-哈希索引"><a href="#5-1-2-哈希索引" class="headerlink" title="5.1.2 哈希索引"></a>5.1.2 哈希索引</h4><p>基于哈希表实现，只有精确匹配索引所有列的查询才有效。<br>​对于每一行数据，存储引擎都会对所有的索引列计算一个哈希吗，哈希吗是一个较小的值，并且不同键值的行计算出来的哈希吗是不一样的。哈希索引将所有的哈希吗存储在索引中，同时在哈希表中保存指向每个数据行的指针。 因为索引只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。哈希索引的限制很多，比如只能进行等值比较查询。</p>
<h4 id="5-1-3空间数据索引"><a href="#5-1-3空间数据索引" class="headerlink" title="5.1.3空间数据索引"></a>5.1.3空间数据索引</h4><h4 id="5-1-4-全文索引"><a href="#5-1-4-全文索引" class="headerlink" title="5.1.4 全文索引"></a>5.1.4 全文索引</h4><p>是一种特殊类型的索引，它查找的是文本中的关键字词，而不是直接比较索引中的值。全文索引更类似于搜索引擎做的事情，而不是简单的WHERE条件匹配。</p>
<h3 id="5-2-索引的优点"><a href="#5-2-索引的优点" class="headerlink" title="5.2 索引的优点"></a>5.2 索引的优点</h3><p><strong>索引可以让服务器快速定位到表的指定位置。B-Tree索引是按照顺序存储数据。</strong><br>索引总结下来有如下三个优点：</p>
<ol>
<li>索引大大减少服务器需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>索引可以将随机I/O变成顺序I/O</li>
</ol>
<blockquote>
<p><strong>注意：对于小表：不用建索引，对于中表：索引很高效。对于大表：建立索引的成本太高</strong></p>
</blockquote>
<h3 id="5-3-高性能的索引策略"><a href="#5-3-高性能的索引策略" class="headerlink" title="5.3 高性能的索引策略"></a>5.3 高性能的索引策略</h3><h4 id="5-3-1-独立的列"><a href="#5-3-1-独立的列" class="headerlink" title="5.3.1 独立的列"></a>5.3.1 独立的列</h4><p>独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。始终将索引列放在符号的一侧。</p>
<h4 id="5-3-2-前缀索引和索引选择性"><a href="#5-3-2-前缀索引和索引选择性" class="headerlink" title="5.3.2 前缀索引和索引选择性"></a>5.3.2 前缀索引和索引选择性</h4><h4 id="5-3-3-多列索引"><a href="#5-3-3-多列索引" class="headerlink" title="5.3.3 多列索引"></a>5.3.3 多列索引</h4><h4 id="5-3-4-选择合适的索引列顺序"><a href="#5-3-4-选择合适的索引列顺序" class="headerlink" title="5.3.4 选择合适的索引列顺序"></a>5.3.4 选择合适的索引列顺序</h4><h4 id="5-3-5-聚簇索引"><a href="#5-3-5-聚簇索引" class="headerlink" title="5.3.5 聚簇索引"></a>5.3.5 聚簇索引</h4><p>将数据行和索引放在一起。</p>
<p> InnodDB通过主键聚集数据。二级索引需要两次索引查找，而不是一次。因为二级索引的叶子节点保存的是行的主键值。</p>
<p><strong>顺序的主键并不一定都是好的，对于高并发工作负载，在InnoDB中按主键顺序插入可能会造成明显的争用。</strong></p>
<ol>
<li><strong>主键上界成为“热点”</strong>，因为所有的插入都发生在这里，并发插入可能造成间隙锁竞争</li>
<li>AUTO_increment锁机制，遇到这个问题考虑重新设计表或者应用，或者更改innodb_autoinc_lock_mode配置。                          </li>
</ol>
<h4 id="5-3-6-覆盖索引"><a href="#5-3-6-覆盖索引" class="headerlink" title="5.3.6 覆盖索引"></a>5.3.6 覆盖索引</h4><p>索引中包含所有需要查询的字段的值，也就是说可以通过索引直接获取列的数据，不需要再读取数据行。<br> 能够极大的提高性能。查询只需要扫描索引而无需回表。            </p>
<h4 id="5-3-7-使用索引扫描来做排序"><a href="#5-3-7-使用索引扫描来做排序" class="headerlink" title="5.3.7 使用索引扫描来做排序"></a>5.3.7 使用索引扫描来做排序</h4><p>只有当索引的列方向顺序和ORDER BY子句的顺序完全一致，并且列的排序方向（倒序或正序）都一样时，<br>MySQL才能够使用索引来对结果做排序。多表关联时，只有order by子句引用的字段全部为第一个表时，才会使用索引做排序。</p>
<h4 id="5-3-8-压缩（前缀压缩）索引"><a href="#5-3-8-压缩（前缀压缩）索引" class="headerlink" title="5.3.8 压缩（前缀压缩）索引"></a>5.3.8 压缩（前缀压缩）索引</h4><h4 id="5-3-9-冗余和重复索引"><a href="#5-3-9-冗余和重复索引" class="headerlink" title="5.3.9 冗余和重复索引"></a>5.3.9 冗余和重复索引</h4><p>MySQL的唯一限制和主键限制都是通过索引来实现的。<br>如果创建了索引（A,B），再创建索引（A）就是冗余索引，因为这只是前一个索引的前缀索引。<br>冗余索引通常发生在为表添加新索引的时候。<br>大多数情况下都不需要冗余索引，应该尽量拓展已有的索引不是创建新索引。</p>
<h4 id="5-3-10-未使用的索引"><a href="#5-3-10-未使用的索引" class="headerlink" title="5.3.10 未使用的索引"></a>5.3.10 未使用的索引</h4><p>建议删除。使用Percona Server或Percona Toolkit中的pt-index-usage进行定位未使用的索引。</p>
<h4 id="5-3-11-索引和锁"><a href="#5-3-11-索引和锁" class="headerlink" title="5.3.11 索引和锁"></a>5.3.11 索引和锁</h4><p>索引会对数据行进行排序，如果你的查询从不访问那些不需要的行，那么使用索引进行查询可以锁定更少的行。</p>
<h3 id="5-4-索引案例学习"><a href="#5-4-索引案例学习" class="headerlink" title="5.4 索引案例学习"></a>5.4 索引案例学习</h3><ol>
<li><p><strong>支持多种过滤条件</strong></p>
</li>
<li><p><strong>避免多个范围条件</strong></p>
<p> in 和 where 的查询类型type都是“range”类型，但其实in的查询就是多个等值查询。对于范围条件查询，MySQL无法再使用范围列后面的索引列了，<br><strong>但是对于“多个等值条件查询”则没有这个限制。</strong></p>
</li>
<li><p><strong>优化排序</strong></p>
<p>比如查询分页时比较靠后的数据，有一个比较好的策略就是延迟关联，通过使用覆盖索引查询需要返回的主键，在根据这些主键关联原表</p>
</li>
</ol>
<h3 id="5-5-维护索引和表"><a href="#5-5-维护索引和表" class="headerlink" title="5.5 维护索引和表"></a>5.5 维护索引和表</h3><p>维护表有三个主要的目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。</p>
<ol>
<li><p><strong>找到并修复损坏的表</strong></p>
<p>对于MyISAM存储引擎，表损坏通常是系统崩溃造成的。<br>使用CHECK TABLE &lt;表名&gt; 来检查表是否损坏，使用REPAIR TABLE &lt;表名&gt;</p>
</li>
<li><p><strong>更新索引统计信息</strong></p>
<p>可以使用ANALYZE TABLE命令获取统计信息</p>
</li>
<li><p><strong>减少索引和数据的碎片</strong></p>
<p>B-Tree索引可能会碎片化，这会降低查询的效率。<br>表的数据也可能会碎片化，有三种类型的数据碎片：</p>
<ol>
<li><p>行碎片</p>
</li>
<li><p>行间碎片</p>
</li>
<li><p>剩余空间碎片</p>
<p>可以通过OPTIMIZE TABLE或者导入再导出的方式来重新整理数据。</p>
</li>
</ol>
</li>
</ol>
<h3 id="5-6-总结"><a href="#5-6-总结" class="headerlink" title="5.6 总结"></a>5.6 总结</h3><p>在选择索引和编写利用这些索引的查询时，有如下三个原则始终需要记住：</p>
<ol>
<li><p><strong>单行访问时很慢的。</strong></p>
</li>
<li><p><strong>按顺序访问数据时很快的。</strong></p>
</li>
<li><p><strong>索引覆盖查询时很快的。</strong></p>
<p>如果一个索引包含了查询中的所有列，那么存储引擎就不需要再回表查询。这就避免了大量的单行访问，单行访问时很慢的。</p>
<p><strong>发现sql查询比较慢时，使用explain来剖析该sql。</strong>  </p>
</li>
</ol>
<h2 id="第6章-查询性能优化"><a href="#第6章-查询性能优化" class="headerlink" title="第6章 查询性能优化"></a>第6章 查询性能优化</h2><p>库表结构优化，索引优化，查询优化才能实现高性能。减少查询的响应时间。</p>
<h3 id="6-1-为什么查询会慢"><a href="#6-1-为什么查询会慢" class="headerlink" title="6.1 为什么查询会慢"></a>6.1 为什么查询会慢</h3><p>查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后咋服务器上进行解析，生成执行计划，执行，并返回结果给客户端。其中“执行”被认为是最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序，分组等。</p>
<h3 id="6-2-慢查询基础：优化数据访问"><a href="#6-2-慢查询基础：优化数据访问" class="headerlink" title="6.2 慢查询基础：优化数据访问"></a>6.2 慢查询基础：优化数据访问</h3><p>查询性能最基本的原因就是向数据库放为的数据太多。<br>对于低效的查询，通过以下两个步骤来分析总是很有效。</p>
<ol>
<li>确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，当有时候也有可能是访问了太多的列。</li>
<li>确认MySQL服务器层是否放在分析大量超过需要的数据行。</li>
</ol>
<p><strong>具体优化</strong>       </p>
<ol>
<li><p><strong>是否向数据库请求了不需要的数据</strong></p>
<p>请求了不需要的数据的话会给MySQL带来额外的负担，并增加网络开销，另外也会消耗应用服务器的CPU和内存资源。</p>
<p>典型案例：查询不需要的记录  </p>
<ol>
<li>多表关联时返回全部列</li>
<li>总是取出全部列：最好不要使用SELECT * 。</li>
<li>重复查询相同的数据：第一次查询的建议缓存起来，以后查询就直接从缓存中读取。        </li>
</ol>
</li>
<li><p><strong>MySQL是否在扫描额外的记录</strong></p>
<p>在确定查询值返回需要的数据以后， 接下来应该看看查询为了返回结果是否 扫描了过多的数据。<br>衡量查询开销的三个指标：</p>
<ol>
<li>响应时间</li>
<li>查询的行数</li>
<li>返回的行数</li>
</ol>
<p><strong>这三个指标都会记录到MySQL的慢日志中</strong></p>
<ol>
<li><p><strong>响应时间</strong></p>
<p>响应时间是两个部分之和：<strong>服务时间</strong>和<strong>排队时间</strong>。</p>
<p>服务时间：是指数据库处理这个查询真正花了多少时间。</p>
<p>排队时间：是指服务器因为等待某些资源而没有真正执行查询的时间——可能是等I/O操作完成，也可能是等待行锁等等。</p>
</li>
<li><p><strong>扫描的行数和返回的行数</strong></p>
</li>
<li><p><strong>扫描的行数和访问类型</strong></p>
<p>EXPLAIN语句中的type列表示访问类型。</p>
<p>访问类型有全盘扫描，索引扫描，范围扫描，唯一索引扫描，常数引用等。<br>type – 连接类型。这里只记录和理解最重要且经常遇见的六种类型，它们分别是all,index,range,ref,ref_eq，const。从左到右，它们的效率依次是增强的。</p>
<ol>
<li><p><strong>all：全表扫描</strong></p>
</li>
<li><p><strong>index</strong></p>
<p>这种连接类型只是另外一种形式的全表扫描，只不过它的扫描顺序是按照索引的顺序，然后根据索引回表取数据。</p>
</li>
<li><p><strong>range</strong></p>
<p>range指的是有范围的索引扫描，相对于index的全索引扫描，它有范围限制，因此要优于index。关于range比较容易理解，需要记住的是出现了range，则一定是基于索引的。同时除了显而易见的between，and以及’&gt;’,’&lt;’外，in和or也是索引范围扫描。</p>
</li>
<li><p><strong>ref</strong></p>
<p>查找条件列使用了索引而且不为主键和unique。其实，意思就是虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。</p>
</li>
<li><p><strong>ref_eq</strong> </p>
<p>使用了主键或者唯一性索引进行查找，这种连接类型每次都进行着精确查询，无需过多的扫描，因此查找效率更高，当然列的唯一性是需要根据实际情况决定的。</p>
</li>
<li><p><strong>const</strong></p>
<p>通常情况下，如果将一个主键放置到where后面作为条件查询，mysql优化器就能把这次查询优化转化为一个常量。至于如何转化以及何时转化，这个取决于优化器。好的索引可以让查询使用合适的访问类型，尽可能的只扫描需要的行。</p>
<p>理解一个查询需要扫描多少行和实际需要使用的行数需要先去理解这个查询背后的逻辑和思想。<br>如果发现查询需要扫描大量的数据但只返回少量的行数，那么通常可以尝试下面的技巧去优化它。</p>
<ol>
<li>使用索引覆盖扫描，把所有需要用到的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了。</li>
<li>改变库表结构。例如使用单独的汇总表。</li>
<li>重写这个复杂的查询，让MySQL优化器能够以更优化的方式执行这个查询。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="6-3-重构查询的方式"><a href="#6-3-重构查询的方式" class="headerlink" title="6.3 重构查询的方式"></a>6.3 重构查询的方式</h3><ol>
<li><p><strong>一个复杂查询还是多个简单查询</strong></p>
<p>在其他条件都相同的时候，使用尽可能少的查询自然是更好的。但是有时候，将一个大查询分解为多个小查询是很有必要的。</p>
</li>
<li><p><strong>切分查询</strong></p>
<p>对于一个大查询有时候需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分,每次只完成一小部分查询结果。</p>
<p>比如删除旧的数据，可以分多次删除。</p>
</li>
<li><p><strong>分解关联查询</strong></p>
<p>可以对每一个表进行一次简单的查询，然后将结果在应用程序中进行关联。</p>
<p><strong>用分解关联查询重构查询有如下优势：</strong></p>
<ol>
<li><p>让缓存的效率更高。</p>
</li>
<li><p>将查询分解后，执行单个查询可以减少锁的竞争。</p>
</li>
<li><p>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和高拓展。</p>
</li>
<li><p>查询本身效率也可能会有所提升。</p>
</li>
<li><p>可以减少冗余记录的查询。</p>
<p>在很多场景下，通过重构查询将关联放到应用程序中将会更加高效，这样的场景有很多。</p>
<p>比如：当应用能够方便的缓存单个查询结果的时候，当可以将数据分布到不同的MySQL服务器的时候，当能够使用IN()的方式代替关联查询的时候，当查询中使用同一个数据表的时候。<br>​                        </p>
</li>
</ol>
</li>
</ol>
<h3 id="6-4-查询执行的基础："><a href="#6-4-查询执行的基础：" class="headerlink" title="6.4 查询执行的基础："></a>6.4 查询执行的基础：</h3><p><strong>MySQL执行一个查询的过程（流程图见248页）</strong></p>
<ol>
<li><p>客户端发送一条查询给服务器。</p>
</li>
<li><p>服务器会先查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则，进入下一阶段。</p>
</li>
<li><p>服务器进行SQL解析，预处理，再由优化器生成对应的执行计划。</p>
</li>
<li><p>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。</p>
</li>
<li><p>将结果返回给客户端。</p>
<p><strong>具体流程分析</strong>      </p>
</li>
</ol>
<h4 id="6-4-1-SQL客户端-服务器通信协议"><a href="#6-4-1-SQL客户端-服务器通信协议" class="headerlink" title="6.4.1 SQL客户端/服务器通信协议"></a>6.4.1 SQL客户端/服务器通信协议</h4><p>MySQL客户端和服务器之间的通信协议是半双工的。</p>
<p><strong>查询状态：有多种方式可以查看当前的状态，最简单的就是使用SHOW FULL PROCESSLIST命令。</strong></p>
<p><strong>Sleep</strong>：线程正在等待客户端发送新的请求。</p>
<p><strong>Query</strong>：线程正在执行查询或者正在将结果返回给客户端。</p>
<p><strong>Locked</strong>：在MySQL服务层，该线程正在等待表锁。</p>
<p><strong>Analyzing and statistics</strong>：线程正在收集存储引擎的统计信息，并生成查询的执行计划。</p>
<p><strong>Copying to tmp table [on disk]</strong>：线程正在执行查询，并且将其结果集都复制到一个临时表中，这种状态一般要么是在做GROUP BY 操作，要么是文件排序操作，或者是UNION操作。如果这个状态后面还有“on disk”标记，那表示MySQL正在将一个内存临时表放到磁盘上。</p>
<p><strong>Sorting Result</strong>：线程正在对结果集进行排序。</p>
<p><strong>Sending data</strong>：这表示多种情况，线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据。</p>
<h4 id="6-4-2-查询缓存"><a href="#6-4-2-查询缓存" class="headerlink" title="6.4.2 查询缓存"></a>6.4.2 查询缓存</h4><p>在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据（这个查找通过大小写敏感的哈希查找实现）。</p>
<p> 如果命中了查询缓存，那么在返回查询结果之前会检查一次用户权限。这种情况下，不会被解析，不用生成执行计划，不会被执行。</p>
<h4 id="6-4-3-查询优化处理"><a href="#6-4-3-查询优化处理" class="headerlink" title="6.4.3 查询优化处理"></a>6.4.3 查询优化处理</h4><p>查询的生命周期的下一步是将一个SQL转换成一个执行计划，MySQL在依照这个执行计划和存储引擎进行交互。这包括多个子阶段：解析SQL，预处理，优化SQL执行计划。</p>
<ol>
<li><p><strong>语法解析器和预处理</strong></p>
<p>首先，MySQL通过关键字将SQL语句进行解析，并生成一颗对应的”解析树”。MySQL解析器将使用MySQL语法规则验证和解析查询。预处理器则会根据一些MySQL语法规则进一步检查解析树是否合法，例如，这里讲检查数据表和数据里是否存在，还会解析名字和别名，看看它们是否有歧义。下一步预处理器会验证权限。这通常很快，除非服务器上有非常多的权限配置。               </p>
</li>
<li><p><strong>查询优化器</strong></p>
<p>现在语法树被认为是合法的了。并且由优化器转化成执行计划。一条查询可能有多种执行方式，最终都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。</p>
<p>MySQL使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。</p>
<p>优化器在评估成本的时候并不考虑任何层面的缓存，它假设读取任何一行数据都需要一次I/O;</p>
<p>优化策略简单的分为两种</p>
<p><strong>静态优化和动态优化。</strong></p>
<ol>
<li>静态优化：可以直接对解析数进行解析，并完成优化。静态优化在第一次完成后就一直有效，即使使用不同的参数执行相同的查询也不会发生变化。</li>
<li>动态优化：则和查询的上下文有关，也可能与很多其他因素有关，例如WHERE条件中的取值，索引中条目对应的数据行数等。这需要再每次查询时都需要评估。</li>
</ol>
<p><strong>MySQL能够处理的优化类型</strong></p>
<ol>
<li><p><strong>重新定义关联表的顺序</strong>：数据表的关联并不总是按照在查询中指定的顺序进行。决定关联的顺序是优化器很 要的一部分功能。</p>
</li>
<li><p><strong>将外连接转化成内连接</strong></p>
</li>
<li><p><strong>使用等价变换规则</strong>：MySQL可以使用一些等价变换来简化并规范表达式。它可以合并和减少一些比较，还可以移除一些恒成立和恒不成立的判断。</p>
</li>
<li><p><strong>优化COUNT(),MIN()和MAX()</strong></p>
<p>索引可列是否可为空通常可以帮助MySQL优化这类表达式。例如，要找到某一列的最小值，只需要查询B-Tree索引最左端的记录，MySQL可以直接获取索引的第一行记录。类似的，如果要查找一个最大值，也只需要读取B-Tree索引的最后一条记录。使用了这种优化的话，可以从explain语句中看到“Select tables optimized away”,它表示优化器已经从执行计划中移除了这张表，并以一个常数取而代之。类似的，没有任何WHERE条件的COUNT(*)查询通常也可以使用存储引擎提供的一些优化（如MyISAM维护了一个变量来存放数据表的行数）</p>
</li>
<li><p><strong>预估并转化为常数表达式</strong>：当MySQL检测到一个表达式可以转换为常数的时候，就会一直把该表达式作为常数进行优化处理。</p>
</li>
<li><p><strong>覆盖索引扫描</strong>：当索引中的列包含所有查询中所有需要使用的列的时候，MySQL就可以直接通过索引返回需要的数据，而无需回表查询对应的数据行。</p>
</li>
<li><p><strong>子查询优化</strong>：MySQL在某些请况下可以将子查询转换一种效率更高的形式，从而减少多个查询多次对数据的访问。</p>
</li>
<li><p><strong>提前终止查询</strong>：在发现已经满足查询需求的时候，MySQL总是能够立刻终止查询。比如 LIMIT</p>
</li>
<li><p><strong>等值传播</strong>：如果两个列的值通过等式关联，那么MySQL能够将其中一个列的WHERE条件等式传播到另一个列上。</p>
</li>
<li><p><strong>列表IN()的比较</strong>：在很多数据库系统中，IN()完全等同于多个OR条件的子句，因为这两者是完全等价的。在MySQL中这点事不成立的，MySQL先将IN()列表中的数据进行排序，然后通过二分查找的方式来确定列表中的值是否慢则条件。这是一个O(log n)复杂度的操作，等价的转换成OR查询的复杂度为O(n)对于IN()列表中有大量取值的时候，MySQL的处理速度将会更快。</p>
</li>
</ol>
</li>
<li><h4 id="数据和索引的统计信息"><a href="#数据和索引的统计信息" class="headerlink" title="数据和索引的统计信息"></a><strong>数据和索引的统计信息</strong></h4><p>在服务器层有查询优化器，却没有保存数据和索引的统计信息。统计信息由存储引擎实现。MySQL查询优化器在生成执行计划前,需要存储引擎获取相应的统计信息。包括：每个表或者索引有多少个页面，每个表的每个索引的基数是多少，数据行和索引长度，索引的分布信息等。优化器根据这些信息来选择一个最优的执行计划。</p>
</li>
<li><p><strong>MySQL如何执行关联查询</strong></p>
<p>对于UNION查询，MySQL先将一系列的单个查询的结果放到一个临时表中，然后在重新读出临时表数据来完成UNION查询。</p>
</li>
<li><p><strong>执行计划</strong></p>
<p>MySQL生成查询（多表查询）的一颗指令树，然后通过执行引擎完成这颗指令树并返回结果。最终的执行计划包含了重构查询的全部信息。</p>
<p>MySQL的执行计划是一颗左侧深度优先的树。</p>
</li>
<li><p><strong>关联查询优化器</strong></p>
<p>MySQL优化器最重要的一部分就是关联查询优化器，它决定了多个表关联时的顺序。通常多表关联时，可以有多种不同的顺序来获取相同的结果。</p>
<p>关联查询优化器通过评估不同顺序时的成本来选择一个代价小的关联查询。可以使用staraight_join关键字，使查询语句按照原本的顺序来执行，不执行查询优化处理。</p>
</li>
<li><p><strong>排序优化</strong></p>
<p>无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应尽可能避免排序或者尽可能对大量数据进行排序。数据量小，内存中排序。数据量大，将数据分块。在内存中排序，结果放在磁盘上，最最终将结果合并，返回排序结果。</p>
</li>
</ol>
<h4 id="6-4-4-查询执行引擎"><a href="#6-4-4-查询执行引擎" class="headerlink" title="6.4.4 查询执行引擎"></a>6.4.4 查询执行引擎</h4><p>在解析和优化阶段，MySQL将生成查询对应的执行计划，MySQL的执行引擎则根据这个执行计划来完成整个查询。在执行执行计划的过程中，需要调用存储引擎实现的接口，这些接口也就是我们称为“handler API”的接口。实际上，MySQL在优化段就已经为每个表创建了一个hander实例，优化器根据这些实例的接口可以获取表的相关信息，包括表的所有列名，索引统计信息，等等。       </p>
<h4 id="6-4-5-返回结果给客户端"><a href="#6-4-5-返回结果给客户端" class="headerlink" title="6.4.5 返回结果给客户端"></a>6.4.5 返回结果给客户端</h4><p>即使查询不需要返回结果给客户端，MySQL仍然会返回这个查询的一些信息，如影响的行数。如果查询可以被缓存，那么MySQL在这个阶段也会将结果存放到缓存中。MySQL将结果返回给客户端是一个增量，逐步返回的过程。</p>
<p>这样处理有两个好处</p>
<p>服务器端无需存储太多结果，也就不会因为要返回太多结果而消耗太多内存。<br>另外，这样的处理也能让MySQL客户端第一时间获得返回的结果。</p>
<h3 id="6-5-MySQL查询优化器的局限性"><a href="#6-5-MySQL查询优化器的局限性" class="headerlink" title="6.5 MySQL查询优化器的局限性"></a>6.5 MySQL查询优化器的局限性</h3><ol>
<li><p><strong>关联子查询</strong></p>
</li>
<li><p><strong>UNION的限制</strong></p>
<p>MySQL无法将限制条件“下推”到内层，这使得原本能够限制部分返回结果的条件无法应用到内层的条件上。</p>
<p>MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。</p>
</li>
<li><p><strong>索引合并优化</strong></p>
<p>当WHERE子句中包含多个复杂条件的时候，MySQL能够访问单个表的多个索引以合并和交叉过滤的方式来定位查找需要的行。</p>
</li>
<li><p><strong>等值传递</strong>：</p>
<p>这个问题实际上很少会碰到。</p>
</li>
<li><p><strong>并行执行</strong></p>
<p>MySQL无法利用多核特性来并行执行查询。</p>
</li>
<li><p><strong>哈希关联</strong></p>
<p>在本书写作的时候，MySQL并不支持哈希关联——MySQL所有的关联都是嵌套循环关联。</p>
</li>
<li><p><strong>松散索引扫描</strong></p>
</li>
<li><p><strong>最大值和最小值优化</strong></p>
</li>
<li><p><strong>在同一张表上进行查询和更新</strong></p>
<p>MySQL不允许对同一张表进行查询和更新。<br>​    </p>
</li>
</ol>
<h3 id="6-6-查询优化器的提示（hint）"><a href="#6-6-查询优化器的提示（hint）" class="headerlink" title="6.6 查询优化器的提示（hint）"></a>6.6 查询优化器的提示（hint）</h3><h3 id="6-7-优化特定类型的查询"><a href="#6-7-优化特定类型的查询" class="headerlink" title="6.7 优化特定类型的查询"></a>6.7 优化特定类型的查询</h3><ol>
<li><p><strong>优化COUNT()查询</strong></p>
<p>COUNT的作用：COUNT()是一个特殊的函数，有两种非常不同的作用：它可以统计某个列值的数量，也可以统计行数。</p>
<p>如果在COUNT()的括号内指定了列或者列的表达式，则统计的就是这个表达式有值的结果数（不包含NULL）。</p>
<p>COUNT()的另一个作用就是统计结果集的行数。当MySQL确认了括号内的表达式不可能为空时，实际上就是在统计行数。</p>
<p>COUNT(*)的通配符 * 并不会像我们猜想的那样拓展成所有的列，实际上，它会忽略所有的列而直接统计所有的行数。</p>
<p>有一个最常见的错误就是,在括号内指定了列值却希望统计结果集的行数，如果希望知道查询的是结果集的行数，就直接使用COUNT(<em>)，这样写意义清晰，性能上也会更好。</em></p>
<p><strong>count(*)：忽略所有列，直接统计该表的所有行数</strong> </p>
<p><strong>count(列值)：统计该列的不为null的行数。</strong><br>​<br><strong>关于MyISAM的神话</strong></p>
<p>MyISAM的COUNT(<em>)函数在没有WHERE子句时执行的非常快，因为无需实际的计算表的行数。MySQL可以利用MySIAM存储引擎的特性直接获得这个值。如果MySQL知道某列col不可能为NULL值，那么MySQL会将COUNT（col）优化为COUNT(</em>).</p>
<p>当统计带WHERE子句的结果集行数，可以是统计某个列值的数量时，MyISAM的COUNT()和其他存储引擎没有任何不同。</p>
<p>简单的优化</p>
<p><strong>有时候可以利用MyISAM的COUNT(<em>)非常快的特性，来加速一些特定COUNT() 的查询。利用表的行数COUNT(</em>)这个常量来减去查询到相反的数量，</strong> 这样一来可以大大减少扫描的行数。</p>
<p>更复杂的优化</p>
<p><strong>COUNT()一般来说都要扫描大量的数据，才能获取进去的结果，因此很难优化，除了索引覆盖扫描之外，如果这还不够，就需要考虑修改应用的架构，可以增加汇总表。</strong><br>​                                           </p>
</li>
<li><p><strong>优化关联查询</strong>：</p>
<ol>
<li>确保ON或者USING子句中的列上有索引。在创建索引的时候就要考虑到关联的顺序，当表A和表B用列c关联的时候，如果优化器的关联顺序是B、A, 那么就不需要在B表的对应列上建索引。没有用到的索引只会带来额外的负担。一般来说，除非有特别其他理由，否则只需要在关联顺序中的第二个表的相应列上建索引。</li>
<li>确保任何的GROUP BY 和 ORDER BY 中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化这个过程。</li>
</ol>
</li>
<li><p><strong>优化子查询</strong></p>
<p>最好的办法就是尽量不要使用子查询，尽可能的使用关联查询来代替。</p>
</li>
<li><p><strong>优化GROUP BY 和 DISTINCT</strong></p>
<p>在MySQL中，当无法使用索引的时候，GROUP BY 使用两种策略来完成：使用临时表或文件排序来做分组。<br>如果是使用关联查询做分组（GROUP BY），并且是按照查找表中的某个列进行分组，那么通常采用查找表的标志列分组的效率回避其他列高。</p>
</li>
<li><p><strong>优化LIMIT分页</strong>：一个最简单的方法就是使用覆盖索引进行扫描，（否则MySQL需要做大量的文件排序操作）通过写一个包含所有索引的子查询进行关联。这种延迟关联将大大提升查询效率。</p>
</li>
<li><p><strong>优化SQL_CALC_FOUND_ROWS</strong></p>
</li>
<li><p><strong>优化UNION查询</strong></p>
<p>MySQL总是通过创建并填充临时表的方式来执行UNION查询。因此很多优化策略在UNION中会失效。<br>经常需要手工的将WHERE，LIMIT,ORDER BY等子句“下推”到UNION的各个子查询中，以便优化器能够充分利用这些条件进行优化。除非确实需要服务器消除重复的行，否则就一定要使用UNION ALL，这一点很重要。如果没有ALL关键字，MySQL会在临时表加上DISTINCT关键字，这会导致对整个临时表的数据做唯一性检查。这样做的代价很高。即使有ALL关键字，MySQL仍然会使用临时表存储结果。</p>
</li>
<li><p><strong>静态查询分析</strong></p>
</li>
<li><p><strong>使用用户自定义变量</strong>​                   </p>
</li>
</ol>
<h3 id="6-8-案例学习"><a href="#6-8-案例学习" class="headerlink" title="6.8 案例学习"></a>6.8 案例学习</h3><h2 id="第7章-MySQL高级特性"><a href="#第7章-MySQL高级特性" class="headerlink" title="第7章 MySQL高级特性"></a>第7章 MySQL高级特性</h2><p>省略。。。</p>
<h2 id="附录D-EXPLAIN"><a href="#附录D-EXPLAIN" class="headerlink" title="附录D EXPLAIN"></a>附录D EXPLAIN</h2><p><strong>EXPLAIN命令是查看查询优化器如何决定执行查询的主要方法。</strong></p>
<p>调用EXPLAIN：在SELECT前加上EXPLAIN，</p>
<ol>
<li><p><strong>type列</strong></p>
<ol>
<li><p><strong>ALL</strong></p>
<p>全表扫描</p>
</li>
<li><p><strong>index</strong></p>
<p>按照索引顺序进行全表扫描,如果在Extra列看到了“use index” ,说明使用的是覆盖索引。    </p>
</li>
<li><p><strong>range</strong></p>
<p>范围扫描就是一个有限制的索引扫描，它开始于索引的某一点，返回匹配这个值域的行。不用遍历全部索引。</p>
</li>
<li><p><strong>ref</strong></p>
<p>这是一种索引访问（有时也叫索引查找），它返回所有匹配某个单个值的行。</p>
</li>
<li><p><strong>eq_ref</strong></p>
<p>使用这种索引进行查找，MySQL知道最多只能返回一条符合条件的记录。</p>
</li>
<li><p><strong>const,system</strong></p>
<p>当MySQL能对查询的某部分进行优化并将其转换为一个常量时，它就会使用这些访问类型。如根据主键查询</p>
</li>
<li><p><strong>NULL</strong></p>
<p>这种访问方式意味着MySQL能够在优化阶段分解查询语句，在执行阶段甚至用不着再访问表或者索引。例如，从索引列中获取最小值，不需要再执行时访问表。</p>
</li>
</ol>
</li>
<li><p><strong>possible_key列</strong></p>
<pre><code>    这一列显示了查询可以使用哪些索引，这是基于访问你的列和使用的比较操作符来判定的。
    这个列表示在优化过程的早期创建的，因此有些罗列出来的索引可能对于后续优化过程是没用的。</code></pre></li>
<li><p><strong>key列</strong></p>
<p>这一列显示了MysQL决定采用哪个索引来优化对该表的访问。如果该索引在possible_key列中没有，那么MySQL选用它时处于另外的原因。例如：可能选择了一个覆盖索引。</p>
</li>
<li><p><strong>ref列</strong></p>
<p>这一列显示了之前的表在key列记录的索引中查找值所用的列或常量。</p>
</li>
<li><p><strong>rows列</strong></p>
<p>这一列是为了估计为了找到所需的行而读取的行数。这个数字是内嵌循环关联计划里的循环数目。<br>通常把rows列的值相乘，可以粗略的计算真个查询会检查的行数。</p>
</li>
<li><p><strong>Extra列</strong></p>
<ol>
<li><p><strong>Using index</strong></p>
<p>表示MySQL将使用覆盖索引，以避免访问表。不要把覆盖索引和index访问类型弄混了</p>
</li>
<li><p><strong>Using where</strong></p>
<p>如果查询未能使用索引，Using where的作用只是提醒我们MySQL将用where子句来过滤结果集</p>
</li>
<li><p><strong>Using filesort</strong></p>
<p>无法利用索引完成的排序，需要额外的排序操作，可能在内存也可能在磁盘完成，常见于group by和order by 操作中</p>
</li>
<li><p><strong>Using temporary</strong></p>
<p>表示使用了临时表存储中间结果，临时表可以是内存临时表和磁盘临时表。主要常见于group by、order by和多表join等操作中。</p>
</li>
<li><p><strong>Distinct</strong></p>
<p>优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作</p>
</li>
<li><p><strong>Not exists</strong></p>
<p>优化left join操作，一旦它找到了匹配left join标准的行，就不再搜索了</p>
</li>
</ol>
</li>
</ol>
<hr>
<p>sql语句：<br>    开启事务：START TRANSACTION;<br>    查看事务是否自动提交：show variables like ‘autocommit’;<br>    修改事务是否自动提交：set autocommit = 1;   1或者on代表启用，0或者off代表禁用。<br>    查看当前会话隔离级别：SELECT @@tx_isolation;<br>    设置当前会话隔离级别：set session transaction isolation level repeatable read;</p>
<hr>
<p>  一个人有两块手表就永远不知道时间。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>使用prometheus监控SpringBoot项目</title>
    <url>/2020/07/01/cai-yong-prometheus-jian-kong-springboot-xiang-mu/</url>
    <content><![CDATA[<h2 id="1-springboot项目中配置prometheus"><a href="#1-springboot项目中配置prometheus" class="headerlink" title="1. springboot项目中配置prometheus"></a>1. springboot项目中配置prometheus</h2><p> 对于springboot应用，需要以下几个步骤<br>springboot应用开启endpoint，添加actuator的依赖和promethus的依赖</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;io.micrometer&lt;/groupId&gt;
  &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre><p>在yml文件或者properties文件中，加入以下配置：</p>
<pre><code># 监控相关配置
# 开启监控
management:
  endpoints:
    web:
      exposure:
        include: &quot;*&quot;  </code></pre><p>这里需要注意是，”*”号是需要加双引号的。<br>启动项目：访问：<a href="http://ip:port/actuator/prometheus">http://ip:port/actuator/prometheus</a><br>如果有数据展示说明配置成功。要是项目配置了context-path。需要加上context-path的路径。<br>项目里面不建议配置context-path</p>
<h2 id="2-下载prometheus"><a href="#2-下载prometheus" class="headerlink" title="2. 下载prometheus"></a>2. 下载prometheus</h2><p>配置prometheus<br>首先要在官网 <a href="https://prometheus.io/" target="_blank" rel="noopener">https://prometheus.io/</a><br>在下载页面，选择何时的版本下载，推荐下载tar.gz包。下载好后，进行解压。在合适的路径下即可。<br>这里介绍下prometheus的目录和文件：<br>1、prometheus采用的都是yml文件的配置方式。<br>2、在根目录下，有个prometheus.yml配置文件，文件初始化的内容如下： </p>
<pre><code>global:
  scrape_interval:     15s   # 这个是每次数据手机的频率
  evaluation_interval: 15s   # 评估告警规则的频率。

rule_files:
  # - &quot;first.rules&quot;
  # - &quot;second.rules&quot;

scrape_configs:               # 通过这里的配置控制prometheus监控的资源
  - job_name: prometheus      # prometheus自身默认的
    static_configs:
      - targets: [&#39;localhost:9090&#39;]  # 默认暴露的是9090端口服务</code></pre><p>global是全局配置。具体见上面的注释说明。</p>
<h2 id="3-prometheus配置文件修改"><a href="#3-prometheus配置文件修改" class="headerlink" title="3. prometheus配置文件修改"></a>3. prometheus配置文件修改</h2><p>添加我们的应用，对springboot进行监控</p>
<pre><code>- job_name: &#39;spring-sample&#39;
    metrics_path: &#39;actuator/prometheus&#39;    # 这里我们springboot暴露出来的endpoint
    scrape_interval: 5s                    # 信息收集时间是间隔5秒
    static_configs:
    - targets: [&#39;localhost:8778&#39;]          # 这里是springboot暴露出来的地址和端口</code></pre><h2 id="4-启动prometheus"><a href="#4-启动prometheus" class="headerlink" title="4. 启动prometheus"></a>4. 启动prometheus</h2><p>这些配置完成后，可以启动prometheus，<br>cd进到prometheus的根目录<br><strong>linux中prometheus启动命令</strong></p>
<pre><code>./prometheus --config.file=prometheus.yml</code></pre><p><strong>windows中prometheus启动命令</strong></p>
<p>添加：–web.enable-lifecycle<br>这种启动方法使Prometheus支持reload 配置文件**</p>
<pre><code>prometheus.exe --web.enable-lifecycle</code></pre><p><strong>reload地址</strong></p>
<pre><code>http://localhost:9090/-/reload</code></pre><h2 id="5-配置grafana"><a href="#5-配置grafana" class="headerlink" title="5. 配置grafana"></a>5. 配置grafana</h2><p>下载grafana，直接启动即可。</p>
<ol>
<li>启动命令参见官网：./grafana-server web</li>
<li>配置datasource，选择prometheus。这个里面有个很重要的注意点，我看网上很多人在转如何用prometheus监控springboot应用，估计自己没去实际搭建，在interval这个时间上，默认是数字，比如15,代表是15秒。在添加dashboard的时候，会发现监控图标左上角是个红点，报错：Invalid interval string, expecting a number followed by one of “Mwdhmsy” ，这个错的解决方案就是在这些时间间隔后面加个”s”。问题解决。</li>
<li>选择dashboard，import的里输入一个模板，可以去dashboards去找你对应的模板，我们这里选用jvm的4701模板，然后就能看到你的springboot的监控信息了。到此，整个搭建完成。</li>
</ol>
]]></content>
      <categories>
        <category>prometheus</category>
      </categories>
      <tags>
        <tag>prometheus</tag>
      </tags>
  </entry>
</search>
