# MySQL45讲

## 09讲普通索引和唯一索引



假设，执行查询的语句是 select id from T where k=5

### 查询过程

- 对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。
- 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。

 那么，这个不同带来的性能差距会有多少呢？答案是，微乎其微。

你知道的，InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。

因为引擎是按页读写的，所以说，当找到k=5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。

当然，如果k=5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。

但是，我们之前计算过，对于整型字段，一个数据页可以放近千个key，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的CPU来说可以忽略不计。

### 更新过程

**change buffer：**当更新一个数据的时候，如果这个数据所在的数据页在内存里面，那么就会直接更新掉。如果不在内存里面的时候，

那么会先将更新的操作记录在change buffer里面。等到下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。

将change buffer的操作记录应用到原数据页，这个过程称为merge，除了访问数据页会触发merge,系统也会有后台线程定期merge。确保数据的完整性。



唯一索引：由于唯一索引每一次更新数据的时候，都需要将数据页查询出来，判断数据是否重复，索引唯一索引不会触发change buffer。

将数据从磁盘读入内存涉及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。

change buffer适用于写多读少的业务。



总结：如果业务上可以确保数据不会重复，那么就用普通索引，可以利用change buffer，性能上会比较好。

如果业务上不能确保数据不会重复，必须借助唯一索引来判断，那么没办法，就使用唯一索引。

如果在大数据量插入的情况下，发现效率慢，那么唯一索引也是一个排查的方向。